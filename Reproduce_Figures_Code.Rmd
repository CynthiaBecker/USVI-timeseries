---
title: "Code_to_reproduce_Figures"
author: "Cynthia Becker"
date: "2023-03-14"
output:
  html_document:
    keep_md: true
    toc: true
    toc_depth: 3
    number_sections: true
    theme: united
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.retina = 2, fig.path = "figures/fig-")
setwd("~/Documents/Apprill_lab/USVI-timeseries/")
```

# Setup
## Install necessary packages

```{r packages, message=FALSE, warning=FALSE, results='hide'}
# For Maps
library(sf); packageVersion("sf")
library(ggspatial); packageVersion("ggspatial")

# For data wrangling
library(plyr); packageVersion("plyr")
library(dplyr); packageVersion("dplyr")
library(tidyverse); packageVersion("tidyverse")
library(broom); packageVersion("broom")
library(readxl); packageVersion("readxl")

# For microbiome and statistical analyses
library(vegan); packageVersion("vegan")
library(phyloseq); packageVersion("phyloseq")
library(fantaxtic); packageVersion("fantaxtic")
library(rstatix); packageVersion("rstatix")
library(FactoMineR); packageVersion("FactoMineR")
library(breakaway); packageVersion("breakaway")
library(corncob); packageVersion("corncob")
library(speedyseq); packageVersion("speedyseq")
library(randomForest); packageVersion("randomForest")
library(lme4); packageVersion("lme4") # linear mixed effects modeling
library(lmerTest); packageVersion("lmerTest") # linear mixed effects modeling with p-value calculation
library(sjPlot) #may be useful for plotting model results from lmer with plot_model(nh4_model, type = "est")


# For visualization
library(ggplot2); packageVersion("ggplot2")
theme_set(theme_bw()) # get rid of the gray background
library(knitr); packageVersion("knitr")
library(rcartocolor); packageVersion("rcartocolor")
library(ggpubr); packageVersion("ggpubr")
library(factoextra); packageVersion("factoextra")
library(ggpmisc); packageVersion("ggpmisc")
library(pals); packageVersion("pals")
library(patchwork); packageVersion("patchwork")
```

## Read in prepped data

The shapefiles for making the map can be downloaded at the following links:
United States and Territories <https://earthworks.stanford.edu/catalog/stanford-vt021tk4894> 
US Virgin Islands and Puerto Rico Habitats <https://products.coastalscience.noaa.gov/collections/benthic/e95usvi_pr/>
US National Parks <https://public-nps.opendata.arcgis.com/datasets/nps::nps-land-resources-division-boundary-and-tract-data-service/explore?layer=2&location=0.239390%2C-12.497900%2C2.00>

```{r Map Data, message=FALSE, warning=FALSE, results='hide'}
# path to the shapefiles. Download the shapefiles linked above and change the path to use this code
usa <- st_read("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/SiteMap/stanford-vt021tk4894-shapefile/", "vt021tk4894")
sttstj <- st_read("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/SiteMap/stsj_fin")
nps <- st_read("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/SiteMap/NPS_-_Land_Resources_Division_Boundary_and_Tract_Data_Service")
```

Environmental Data

```{r Environmental and benthic data}
envdata <- read_xlsx("data/Env_Data_USVI.xlsx", na = "NA")
reefs <- read.table("data/St.John_sites_latlon.txt", sep = "\t", header = TRUE)
precip <- read.csv("data/EastEndVI_Precip.csv", sep = ",")
temperaturepath <- "data/StJohn_temperature.xlsx"
```


Taxonomic microbiome data (16S rRNA gene abundances)
Import the data that has been filtered for contaminants and low abundance reads
```{r Taxonomic microbiome data}
## Read in data - use the low abundance filtered dataset
asv <- read.table("data/ASV_lowabund_filt.txt",sep="\t",header=TRUE, row.names=1)
taxa <- as.matrix(read.table("data/taxonomy_lowabund_filt.txt", sep="\t", header=TRUE, row.names=1))
samples <- read.table("data/metadata_lowabund_filt.txt",sep="\t",header=T,row.names=1)

colnames(asv) <- str_replace_all(colnames(asv), pattern = "[X]", "")

# Create phyloseq object
ASV = otu_table(asv, taxa_are_rows = TRUE)
TAX = tax_table(taxa)
META = sample_data(samples)

ps <- phyloseq(ASV, TAX, META)
```

# WHAT ABOUT USING THE NON FILTERED DATA FOR THE ALPHA DIVERSITY ANALYSES???????

## Generate functions used in analysis
```{r}
# function for reading in multiple excel sheets
multiplesheets <- function(fname) {
   
  # getting info about all excel sheets
  sheets <- readxl::excel_sheets(fname)
  tibble <- lapply(sheets, function(x) readxl::read_excel(fname, sheet = x))
  data_frame <- lapply(tibble, as.data.frame)
    
  # assigning names to data frames
  names(data_frame) <- sheets
    
  # print data frame
  print(data_frame)
}


# create a function that will return the values of interest from the Differential abundance test
# THis is for when there are two variables tested or compared to the control
extractmods1 <- function(model) {
  result <- data.frame("Estimate" = model$coefficients[2:3, 1], 
                        "Std.Error" = model$coefficients[2:3, 2], 
                        "p" = model$coefficients[2:3, 4])
  return(result)
}

# create a function that will return the values of interest
# This one is for when there is only one comparison
extractmods2 <- function(model) {
  result <- data.frame("Estimate" = model$coefficients[2, 1], 
                        "Std.Error" = model$coefficients[2, 2], 
                        "p" = model$coefficients[2, 4])
  return(result)
}
```

# Figure 1 - Map
```{r Map}
# site metadata
reefs$Site <- factor(reefs$Site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head"))

# Make color palette from colorblind friendly palettes in rcartocolor Safe palette
reefpalette <- c("#88CCEE", "gray60", "#DDCC77", "#117733", 
                 "#332288", "#AA4499", "#44AA99", "tan3")

# Filter to only layers you want
usvi <- usa %>% filter(state == "United States Virgin Islands")
reefZONE <- sttstj %>%
  filter(ZONE %in% c("Forereef", "Reef Crest", "Backreef"))
vicoral <- nps %>% filter(PARKNAME %in% c("Virgin Islands", "Virgin Islands Coral Reef"))

map <- ggplot() +
  geom_sf(data = usvi, fill = "darkgray", color = "darkgray") +
  geom_sf(data = reefZONE, fill = "pink", color = "coral") +
  geom_sf(data = vicoral, fill = NA, color = "tan4", linewidth = 1) +
  coord_sf(xlim = c(-64.8038, -64.685), ylim = c(18.2895, 18.375364), expand = FALSE) +
  geom_point(data = reefs, mapping = aes(x = Lon, y = Lat, fill = Site), pch = 21, size = 4.5) +
  scale_fill_carto_d(palette = "Safe") +
  annotation_scale(location = "bl", width_hint = 0.2) +
  theme(panel.grid.major = element_blank(), panel.background = element_rect(fill = "white"))

#ggsave("figures/STJ_map_3.14.23.pdf")

benthic <- envdata %>%
  filter(site != "USVI Blue Water") %>%
  filter(yearmonth == "2016-06") %>%
  filter(depthtype == "benthic") %>%
  dplyr::select(site, siteacronym, yearmonth, disturbance, BleachCoral:TurfAlgae) %>%
  dplyr::select(-BleachCoral, -DiseasedCoral, -Ramicrusta) %>% #no need for these sections since they are zero
  mutate(site = factor(site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))) %>%
  filter(site != "Sand patch") %>% #no need to calculate sand patch stuff
  mutate(Algae = Macroalgae + TurfAlgae) %>%
  mutate(Coral = HardCoral + SoftCoral) %>%
  mutate(Other = Other + Sponge + Substrate + CCA + CYAN) %>%
  dplyr::select(site, siteacronym, yearmonth, Algae, Coral, Other) %>%
  gather(key = "cover", value = "percent", Algae:Other) %>%
  mutate(cover = factor(cover, levels = c("Coral", "Algae", "Other")))

ggplot(benthic, aes(x = "", y = percent, fill = cover, color = site)) +
  geom_bar(width = 1, position = "fill", stat="identity", linewidth = 1.5) +
  coord_polar("y", start=0) +
  facet_wrap( ~ site, ncol = 8) +
  theme_void() +
  scale_color_manual(values = reefpalette) +
  scale_fill_manual(values = c("black", "gray70", "gray95")) +
  theme(legend.position = "bottom") +
  ggtitle("Figure 1a. Benthic cover at different reef sites")

#ggsave("figures/Benthic_piechart_June2016_3.14.23.pdf", width = 10)
```

# REVISION FIG 1 - ADD BENTHIC COVER OVER TIME
```{r}
coralalgae <- envdata %>%
  filter(site != "USVI Blue Water") %>%
  filter(depthtype == "benthic") %>%
  dplyr::select(Date, site, siteacronym, yearmonth, disturbance, BleachCoral:TurfAlgae) %>%
  mutate(site = factor(site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))) %>%
  filter(site != "Sand patch") %>% #no need to calculate sand patch stuff
  mutate(Algae = Ramicrusta + Macroalgae + TurfAlgae) %>% # only interested in total algae
  mutate(Coral = HardCoral + SoftCoral) %>%               # only interested in total coral
  dplyr::select(Date, site, disturbance, siteacronym, yearmonth, Algae, Coral) %>%
  mutate(disturbance = factor(disturbance, levels = c("historic", "hurricane", "disease"))) %>%
  drop_na(Algae) %>%
  gather(key = "organism", value = "percentcover", Algae:Coral)

benthos <- ggplot(coralalgae, aes(x = Date, y = percentcover, color = site)) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-09-06")), colour = "gray", linewidth = 3) + # Irma and Maria
  geom_vline(xintercept = as.POSIXct(as.Date("2020-06-01")), colour = "gray", linewidth = 3) + # Bleaching event
  geom_point(aes(shape = disturbance), data = coralalgae, size = 4) +
  geom_line(linewidth = 1.2) +
  scale_color_carto_d(palette = "Safe") +
  facet_wrap( ~ organism, scales = "free_y", ncol = 1) +
  labs(y = "Relative cover", x = "Date", color = "Reef", shape = "Disturbance")

ggarrange(map, benthos, labels = c("a.", "b."), widths = c(2,1), common.legend = TRUE, legend = "bottom")
ggsave("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/Publication_Figures/EMI_Revision_Figures/Fig1_map_benthos_revised.pdf", width = 9, height = 5)
```


# Figures 2-4, Environmental Data analysis

## Manipulate data
```{r load data and manipulate}
## Look at pairwise correlation between the variables in all the environmental data
envdata2 <- envdata %>%       
  filter(site != "USVI Blue Water") %>%
  filter(site != "Sand patch") %>%
  mutate(TON = tn_um - (no2no3_um + nh4_um)) %>%
  mutate(no3_um = no2no3_um - no2_um) %>%
  dplyr::select(-Phaeo_ug_per_l, -no2no3_um, -tn_um, -temp_c, -salinity) %>%
  mutate(cellRatio = hbact_per_ml / (pro_per_ml + syn_per_ml + peuk_per_ml)) %>%
  mutate(Pro_fgC = pro_per_ml * 30) %>%
  mutate(Syn_fgC = syn_per_ml * 100) %>%
  mutate(Hbact_fgC = hbact_per_ml * 10) %>%
  mutate(biomassRatio = Hbact_fgC / (Pro_fgC + Syn_fgC)) %>%
  dplyr::select(-Pro_fgC, -Syn_fgC, -Hbact_fgC) %>%
  mutate(Chl_ug_per_l = ifelse(depthtype == "surface", NA, Chl_ug_per_l)) %>% #remove surface chlorophyll values
  mutate(BenthicAlgae = Ramicrusta + Macroalgae + TurfAlgae) %>% # choose true algae only, since CYAN aren't and ignore CCA b/c it is beneficial
  mutate(coral = HardCoral + SoftCoral) %>%
  mutate(AlgaeToCoral = BenthicAlgae / (HardCoral + SoftCoral)) %>%
  dplyr::select(-BleachCoral, -Other, -CYAN, -CCA, -DiseasedCoral, -Sponge, -Substrate) %>% # no need for non-coral or non-algae groups
  mutate(disturbance = factor(disturbance, levels = c("historic", "hurricane", "disease"))) %>%
  mutate(site = factor(site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head"))) %>%
  mutate(disturbance = factor(disturbance, levels = c("historic", "hurricane", "disease"))) 

env.long <- envdata2 %>%
  gather(key = "datatype", value = "value", npoc_um:AlgaeToCoral) %>%
  drop_na(value)

# Remove outliers for the likely erroneously high Chl, ammonium, nitrate, and npoc, since this could cause significant relationships when there potentially are none. This way I am being more cautious. Outliers are ±3 std deviations away from the mean. Remove them.
envdata_olrm <- env.long %>%
  filter(datatype %in% c("Chl_ug_per_l", "nh4_um", "no3_um", "npoc_um")) %>%
  group_by(datatype) %>%
  filter(!(abs(value - median(value)) > 3*sd(value)))

# Add the envdata_olrm back to the env.long dataframe
env.long.olrm <- env.long %>%
  filter(datatype != "Chl_ug_per_l") %>%
  filter(datatype != "nh4_um") %>%
  filter(datatype != "no3_um") %>%
  filter(datatype != "npoc_um") %>%
  bind_rows(envdata_olrm)
```


## Are surface and benthic values distinct?
```{r surface benthic analysis}
# For the benthic data. Do a shapiro-wilk test to test for normality. If normal, do an ANOVA followed by a Tukey HSD post-hoc test. 
surfacebenthic.long <- env.long.olrm %>%
  filter(datatype %in% c("po4_um",
                         "silicate_um",
                         "no2_um",
                         "pro_per_ml",
                         "syn_per_ml",
                         "peuk_per_ml",
                         "hbact_per_ml",
                         "TON",
                         "cellRatio",
                         "biomassRatio",
                         "npoc_um",
                         "nh4_um",
                         "no3_um")) %>%
  filter(value != "Inf")

#check data are normally distributed
normal <- surfacebenthic.long %>%
  group_by(datatype, depthtype) %>%
  do(tidy(shapiro.test(.$value))) %>% 
  ungroup() %>%
  mutate(normal = ifelse(p.value < 0.05, "not_normal", "yes_normal")) %>%
  dplyr::select(datatype, depthtype, normal) %>%
  spread(key = "depthtype", value = "normal")

# Check for homogeneity of variances. This is an assumption of the ANOVA test
variance <- surfacebenthic.long %>%
  group_by(datatype) %>%
  levene_test(value ~ disturbance, center = median) %>% 
  mutate(equalvariance = ifelse(p < 0.05, "no", "yes")) %>%
  dplyr::select(datatype, equalvariance)

# t-test results
ttest <- surfacebenthic.long %>%
  group_by(datatype) %>%
  t_test(value ~ depthtype) %>%
  mutate(t.test.sig = ifelse(p < 0.05, "yes", "no")) %>%
  dplyr::select(datatype, p, t.test.sig)

# Do wilcox test, which is a non-parametric alternative to a t-test
wilcox <- surfacebenthic.long %>%
  group_by(datatype) %>%
  wilcox_test(value ~ depthtype) %>%
  mutate(Wilcox.Sig = ifelse(p < 0.05, "yes", "no")) %>%
  dplyr::select(datatype, p, Wilcox.Sig)

surf_benth_envdata_results <- normal %>%
  left_join(variance, by = "datatype") %>%
  left_join(ttest, by = "datatype") %>%
  left_join(wilcox, by = "datatype") %>%
  mutate(test2use = ifelse(surface == "yes_normal" & benthic == "yes_normal" & equalvariance == "yes", "ttest", "wicox")) %>%
  mutate(Significant = ifelse(test2use == "ttest", t.test.sig, Wilcox.Sig)) %>%
  mutate(p = ifelse(test2use == "ttest", p.x, p.y)) %>%
  dplyr::select(datatype, benthic, surface, test2use, Significant, p)

kable(surf_benth_envdata_results)
```
## ANOVA or Kruskal Wallis tests

Based on the previous results it makes sense to combine the benthic and surface values. Most of the values are NOT different between surface and benthic. Since they aren't much different, I will combine them for the ANOVA and Kruskal-Wallis tests. This will make it easier to interpret and actually addresses the main questions I am interested in.

Default asterisk values are as follows:
<0.05 = *
<0.01 = **
<0.001 = ***
<0.0001 = ****

```{r ANOVA KW stats}
env.data.foranalysis <- env.long.olrm %>%
  filter(datatype != "SCTLDprevalence") %>%
  filter(datatype != "BenthicAlgae") %>%
  filter(datatype != "coral") %>%
  filter(datatype != "cellRatio") %>%
  drop_na(value) %>%
  filter(value != "Inf")

# check if data are normally distributed. This is an assumption of the ANOVA test
normal <- env.data.foranalysis %>%
  group_by(datatype, disturbance) %>%
  shapiro_test(value) %>% 
  mutate(normal = ifelse(p < 0.05, "not_normal", "yes_normal")) %>%
  dplyr::select(datatype, disturbance, normal) %>%
  spread(key = "disturbance", value = "normal")

# Check for homogeneity of variances. This is an assumption of the ANOVA test
variance <- env.data.foranalysis %>%
  group_by(datatype) %>%
  levene_test(value ~ disturbance, center = median) %>% 
  mutate(equalvariance = ifelse(p < 0.05, "no", "yes")) %>%
  dplyr::select(datatype, equalvariance)

# ANOVA results
anova <- env.data.foranalysis %>%
  group_by(datatype) %>%
  do(tidy(aov(.$value ~ .$disturbance))) %>%
  filter(term == ".$disturbance") %>%
  mutate(sig05 = ifelse(p.value < 0.05, "yes", "no")) %>%
  dplyr::select(datatype, sig05, p.value) %>%
  dplyr::rename(p = p.value)

# Pairwise results with the Tukey Honest significant differences
ANOVA.tukey <- env.data.foranalysis %>%
  group_by(datatype) %>%
  tukey_hsd(value ~ disturbance) %>%
  mutate(TukeyHSDtest = paste0(group1, "-", group2), 
         p.adj.signif = paste("Tukey", p.adj.signif)) %>%
  dplyr::select(datatype, TukeyHSDtest, p.adj.signif) %>%
  spread(key = "TukeyHSDtest", value = "p.adj.signif") %>%
  left_join(anova, by = "datatype")

# Do kruskal wallis test since for many of the variables, the assumptions are not met for an ANOVA
KW <- env.data.foranalysis %>%
  group_by(datatype) %>%
  kruskal_test(value ~ disturbance) %>%
  mutate(sig05 = ifelse(p < 0.05, "yes", "no")) %>%
  dplyr::select(datatype, sig05, p)

# Dunns post-hoc test
KW.dunn <- env.data.foranalysis %>%
  group_by(datatype) %>%
  dunn_test(value ~ disturbance) %>%
  mutate(DunnPostHoc = paste0(group1, "-", group2), 
         p.adj.signif = paste("Dunn", p.adj.signif)) %>%
  dplyr::select(datatype, DunnPostHoc, p.adj.signif) %>%
  spread(key = "DunnPostHoc", value = "p.adj.signif") %>%
  left_join(KW, by = "datatype")

#put it all together and summarize p-values
statresults <- normal %>%
  left_join(variance, by = "datatype") %>%
  mutate(test2use = ifelse(historic == "yes_normal" & hurricane == "yes_normal" & disease == "yes_normal" & equalvariance == "yes", "ANOVA", "Kruskal-Wallis"))

statresults.ANOVA <- statresults %>%
  filter(test2use == "ANOVA") %>%
  left_join(ANOVA.tukey, by = "datatype")

statresults.KW <- statresults %>%
  filter(test2use == "Kruskal-Wallis") %>%
  left_join(KW.dunn, by = "datatype")

statsummaries <- bind_rows(statresults.ANOVA, statresults.KW) %>%
  mutate(sig01 = ifelse(p < 0.01, "yes", "no")) %>%
  mutate(sigBonf = ifelse(p < (0.05/nrow(statresults)), "yes", "no"))

kable(statsummaries)
```

## Benthic changes with disturbance

```{r benthic}
## Conduct a PCA
benthic <- envdata %>%
  filter(site != "USVI Blue Water") %>%
  dplyr::select(Date, site, siteacronym, depthtype, yearmonth, disturbance, BleachCoral, CCA, CYAN, DiseasedCoral, HardCoral, Macroalgae, Other, Ramicrusta, SoftCoral, Sponge, Substrate, TurfAlgae) %>%
  mutate(site = factor(site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))) %>%
  drop_na(HardCoral) %>%
  filter(site != "Sand patch") %>% #no need to calculate sand patch stuff
  mutate(Other = Other + BleachCoral) %>% # add bleached coral to the grouping with Other
  dplyr::select(-BleachCoral) #no need for this section

# Prep the benthic data 
pca_data_short_final <- as.matrix(benthic) #change from tibble to matrix
rownames(pca_data_short_final) <- pca_data_short_final[,3] #make rownames the unique sites
pca_data_short_final <- pca_data_short_final[,7:17] #select numeric variables
class(pca_data_short_final) <- "numeric" #change from character to numeric values for pca

#Do the PCA
pca <- PCA(pca_data_short_final, scale.unit=TRUE, graph = FALSE) #performs the Principal component analysis #scale.unit=TRUE then data are scaled to unit variance

# how many dimensions explain the data?
# fviz_eig(pca) #1st dimension is most. 2,3,and 4 are a lot of them too

#All pca values for density plots to acompany the ggplot summary figure
pcaAll <- cbind(benthic, pca$ind$coord[,1:2]) %>%
  mutate(disturbance = factor(disturbance, levels = c("historic", "hurricane", "disease")))

pcaplot2 <- ggscatter(pcaAll, x = "Dim.1", y = "Dim.2", color = "disturbance", size = 4, alpha = 0.7, palette = "Dark2") +
  labs(x = "PC1 (27.2%)", y = "PC2 (15.2%)") +
  border()+
  theme(legend.position = "none")

cx <- ggplot(pcaAll, aes(x = disturbance, y = Dim.1, fill = disturbance)) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Dark2") +
  rotate() +
  clean_theme()+
  theme(legend.position = "none")

dy <- ggplot(pcaAll, aes(x = disturbance, y = Dim.2, fill = disturbance)) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Dark2") +
  clean_theme() +
  theme(legend.position = "none")

## Create graphs of significant and not significant variables from ANOVA and Kruskal-Wallis tests
benthic_vars <- c("HardCoral","Macroalgae","Ramicrusta","SoftCoral","TurfAlgae")

benthic_sigvars <- c("Macroalgae","Ramicrusta","TurfAlgae")

benthic_notsigvars <- c("HardCoral","SoftCoral")

benthic.forFigures <- env.long.olrm %>%
  filter(datatype %in% benthic_vars) %>%
  drop_na(value) %>%
  mutate(datatype = factor(datatype, levels = c("Ramicrusta","TurfAlgae","Macroalgae","HardCoral","SoftCoral")))

sig <- benthic.forFigures %>%
  filter(datatype %in% benthic_sigvars) %>%
  mutate(datatype = factor(datatype, levels = c("Ramicrusta","TurfAlgae","Macroalgae")))

notsig <- benthic.forFigures %>%
  filter(datatype %in% benthic_notsigvars) %>%
  mutate(datatype = factor(datatype, levels = c("HardCoral","SoftCoral")))

# significantly changing by disturbance (p<0.05 and <bonf corrected p)
bplot <- ggplot(sig, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Relative cover", x = "Disturbance event", color = "Disturbance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap( ~ datatype, scales = "free_y", ncol = 2)

# FIGURE 2

# Arranging the plot
fig2 <- ggarrange(ggarrange(cx, NULL, pcaplot2, dy, 
          ncol = 2, nrow = 2,  align = "hv", 
          widths = c(4,1), heights = c(1, 4)), 
          bplot, labels = c("a.", "b."))
annotate_figure(fig2, top = "Figure 2. Benthic composition at eight reefs significantly changed with disturbances")

#Use vegan for the benthic pca stuff - PCAs are made with euclidian distance so use adonis function but make sure method = "eu"
# Interested in how environmental variables influence benthic composition
site <- adonis2(pca_data_short_final ~ site, data = benthic, method = "eu")
site

dist <- adonis2(pca_data_short_final ~ disturbance, data = benthic, method = "eu")
dist

date <- adonis2(pca_data_short_final ~ Date, data = benthic, method = "eu")
date

# not significantly changing benthic variables
ggplot(notsig, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Relative cover", x = "Disturbance event", color = "Disturbance", title = "Supplementary Figure S2") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap( ~ datatype, scales = "free_y")

# phase shift diagram
phaseshift <- env.long.olrm %>%
  filter(datatype %in% c("BenthicAlgae", "coral", "AlgaeToCoral")) %>%
  spread(key = "datatype", value = "value")

phase <- ggplot(phaseshift, aes(x = coral, y = BenthicAlgae, color = disturbance)) +
  geom_point(size = 4, alpha = 0.8) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "Hard and soft coral cover", y = "Algal cover", color = "Disturbance", title = "Figure S3")

ratio <- ggplot(phaseshift, aes(x = disturbance, y = AlgaeToCoral)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Ratio of algae to coral", x = "Disturbance event", color = "Disturbance", title = "Figure S3") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") 

ggarrange(phase, ratio, ncol = 2, labels = c("a.",  "b."), common.legend = TRUE) + 
  ggtitle("Supplementary Figure S3")
```
By what percent did hard coral decrease from the hurricane period to the end of the study in the disease period? Average (within reefs) hurricane values and disease values and get a percent per reef before and after.
```{r}
hardcoral <- benthic.forFigures %>%
  filter(datatype == "HardCoral") %>%
  filter(disturbance != "historic") %>%
  group_by(disturbance, site) %>%
  summarise(avg_HardCoral = mean(value)) %>%
  tidyr::spread(key = disturbance, value = avg_HardCoral) %>%
  mutate(coral_change = hurricane - disease) %>%
  mutate(percent_decrease = (coral_change / hurricane)* 100)

kable(hardcoral)
```

By what percent did turf algae and Ramicrusta increase from the beginning to the end of the study in the disease period? Average (within reefs) historic or hurricne (for ramicrusta) values and disease values and get a percent per reef before and after.
```{r}
turfalgae <- benthic.forFigures %>%
  filter(datatype == "TurfAlgae") %>%
  filter(disturbance != "hurricane") %>%
  group_by(disturbance, site) %>%
  summarise(avg_TA = mean(value)) %>%
  tidyr::spread(key = disturbance, value = avg_TA) %>%
  mutate(TA_change = disease - historic) %>%
  mutate(percent_increase = (TA_change / historic)* 100)

kable(turfalgae)

mean(turfalgae$percent_increase)
sd(turfalgae$percent_increase)

# Use the hurricane time period because we didn't always account for ramicrusta
ramicrusta <- benthic.forFigures %>%
  filter(datatype == "Ramicrusta") %>%
  filter(disturbance != "historic") %>%
  group_by(disturbance, site) %>%
  summarise(avg_RC = mean(value)) %>%
  tidyr::spread(key = disturbance, value = avg_RC) %>%
  mutate(RC_change = disease - hurricane) %>%
  mutate(percent_increase = (RC_change / hurricane)* 100)

kable(ramicrusta)

mean(ramicrusta$percent_increase)
sd(ramicrusta$percent_increase)
```



## Nutrient changes with disturbance

```{r nutrient data for publication}
nuts_vars <- c("po4_um","silicate_um","no2_um", "TON", "npoc_um","nh4_um","Chl_ug_per_l","no3_um")

nuts_sigvars <- c("po4_um","silicate_um","TON","nh4_um","Chl_ug_per_l")

nuts_notsigvars <- c("no2_um", "npoc_um", "no3_um")

nuts.forFigures <- env.long.olrm %>%
  filter(datatype %in% nuts_vars) %>%
  drop_na(value) %>%
  mutate(datatype = factor(datatype, levels = c("nh4_um","TON","Chl_ug_per_l","po4_um","silicate_um", "npoc_um","no2_um", "no3_um")))

sig <- nuts.forFigures %>%
  filter(datatype %in% nuts_sigvars) %>%
  mutate(datatype = factor(datatype, levels = c("nh4_um","TON","Chl_ug_per_l","po4_um","silicate_um")))

notsig <- nuts.forFigures %>%
  filter(datatype %in% nuts_notsigvars) %>%
  mutate(datatype = factor(datatype, levels = c("npoc_um","no2_um", "no3_um")))

# significantly changing by disturbance (p<0.05 and <bonf corrected p)
ggplot(sig, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Concentration", x = "Disturbance event", color = "Disturbance", title = "Figure 3.") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap( ~ datatype, scales = "free_y")

#ggsave("../figures/Nutrients_significant.pdf")

# not significantly changing
ggplot(notsig, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Concentration", x = "Disturbance event", color = "Disturbance", title = "Supplementary Figure S4") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap( ~ datatype, scales = "free_y")

#ggsave("../figures/Nutrients_NOT_sig.pdf")
```

## Cell abundance changes with disturbance

```{r  publication figures for cell abundances}
cells_vars <- c("pro_per_ml","syn_per_ml","peuk_per_ml","hbact_per_ml","biomassRatio")

cells_sigvars <- c("pro_per_ml","peuk_per_ml","biomassRatio")

cells_notsigvars <- c("syn_per_ml","hbact_per_ml")

cells.forFigures <- env.long.olrm %>%
  filter(datatype %in% cells_vars) %>%
  drop_na(value) %>%
  mutate(datatype = factor(datatype, levels = c("pro_per_ml","peuk_per_ml","syn_per_ml","hbact_per_ml","biomassRatio")))

sig <- cells.forFigures %>%
  filter(datatype %in% cells_sigvars) %>%
  mutate(datatype = factor(datatype, levels = c("pro_per_ml","peuk_per_ml","biomassRatio")))

notsig <- cells.forFigures %>%
  filter(datatype %in% cells_notsigvars) %>%
  mutate(datatype = factor(datatype, levels = c("syn_per_ml","hbact_per_ml")))

# significantly changing by disturbance (p<0.05 and <bonf corrected p)
ggplot(sig, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Abundance (cells per milliliter)", x = "Disturbance event", color = "Disturbance", title = "Figure 4") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap( ~ datatype, scales = "free_y")

#ggsave("../figures/Cells_sig_disturbance.pdf")

# not significantly changing
ggplot(notsig, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Abundance (cells per milliliter)", x = "Disturbance event", color = "Disturbance", title = "Figure S6") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap( ~ datatype, scales = "free_y")

#ggsave("../figures/Cells_NOT_sig_disturbance.pdf")

```

By what percent did prochlorococcus decrease between historic and disease time points? Average (within reefs) historic values and disease values and get a percent per reef before and after. This shows the cumulative change in prochlorococcus over the course ofthe study. 
```{r}
pro_cumulative_change <- cells.forFigures %>%
  filter(datatype == "pro_per_ml") %>%
  filter(disturbance != "hurricane") %>%
  group_by(disturbance, site) %>%
  summarise(avg_Pro = mean(value)) %>%
  tidyr::spread(key = disturbance, value = avg_Pro) %>%
  mutate(Pro_change = historic - disease) %>%
  mutate(percent_decrease = (Pro_change / historic)* 100)

kable(pro_cumulative_change)

mean(pro_cumulative_change$percent_decrease)
sd(pro_cumulative_change$percent_decrease)
```


# Alpha and beta diversity analyses

## Alpha diversity

### Does depth influence alpha diversity?
```{r publication figures Alpha diversity}
#set levels
sample_data(ps)$date <- as.Date(sample_data(ps)$date)
sample_data(ps)$site <- factor(sample_data(ps)$site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))
sample_data(ps)$disturbance <- factor(sample_data(ps)$disturbance, levels = c("historic", "hurricane", "disease"))
sample_data(ps)$depthtype <- factor(sample_data(ps)$depthtype, levels = c("benthic", "surface"))

### Does Alpha diversity change with depth?? ###
# estimate richness
richness <- ps %>% breakaway        # estimate true richness

# Do inference on richness - I hypothesize that richness changes with depth
meta_richness <- ps %>%
  sample_data %>%
  as_tibble %>%
  mutate("sample_names" = ps %>% sample_names) %>%
  left_join(summary(richness),
            by = "sample_names") 

# Test the effect of depth on estimated richness
bt_depth_fixed <- betta(formula = estimate ~ depthtype, 
                      ses = error, data = meta_richness)
bt_depth_fixed$table
bt_depth_fixed$global[2]

alphadepth <- ggplot(meta_richness, aes(x = depthtype, y = estimate)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = depthtype, shape = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Breakaway estimate of richness", x = "Disturbance", color = "Depth", shape = "Disturbance", 
       title = "Benthic microbial richness changes with disturbance") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))
```
Based on this, alpha diversity significantly changes with depth, therefore, I will split up the alpha diversity analyses. 

### Benthic - Does disturbance and reef influence alpha diversity?
```{r alpha diversity benthic}
## BENTHIC ANALYSIS FIRST #####
ps.a_benthic <- ps %>%
  subset_samples(site != "Sand patch") %>%  # get rid of sandpatch
  subset_samples(depth == "Benthic")        # only interested in benthic data

benthic_richness <- ps.a_benthic %>% breakaway        # estimate true richness

# Do inference on richness - I hypothesize that richness changes by reef and disturbance
benthic_meta_richness <- ps.a_benthic %>%
  sample_data %>%
  as_tibble %>%
  mutate("sample_names" = ps.a_benthic %>% sample_names) %>%
  left_join(summary(benthic_richness),
            by = "sample_names")

# Test the effect of Reef (site), disturbance, and disturbance with reef as a random effect
set.seed(100)
bt_site_fixed <- betta(formula = estimate ~ site, 
                      ses = error, data = benthic_meta_richness)
bt_site_fixed$table
bt_site_fixed$global[2] # get global p-value to see if there are changes across all reefs

bt_disturbance_fixed <- betta(formula = estimate ~ disturbance, 
                      ses = error, data = benthic_meta_richness)
bt_disturbance_fixed$table
bt_disturbance_fixed$global[2] # get global p-value to see if there are overall changes across disturbance

# check if the richness changes with disturbance within each reef site (adding in random effects)
bt_disturbance_fixed_site_random <- betta_random(chats = benthic_meta_richness$estimate,
                                       ses = benthic_meta_richness$error,
                                       X = model.matrix(~ disturbance, data = benthic_meta_richness),
                                       groups = benthic_meta_richness$site)
bt_disturbance_fixed_site_random$table
bt_disturbance_fixed_site_random$global[2]

## Make graphs that display the different alpha diversity metrics:

b <- ggplot(benthic_meta_richness, aes(x = disturbance, y = estimate)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Breakaway estimate of richness", x = "Disturbance", color = "Disturbance", 
       title = "Figure 5b. Benthic richness") +
  scale_color_brewer(palette = "Dark2") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))


# Graph disturbance and reef together
c <- ggplot(benthic_meta_richness, aes(x = disturbance, y = estimate)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7)+
  facet_wrap(~ site, ncol = 8) +
  labs(y = "Breakaway estimate of richness", x = "Disturbance", color = "Disturbance", 
       title = "Figure S8 b. Benthic microbial richness changes with disturbance") +
  scale_color_brewer(palette = "Dark2") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        legend.position = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))


# Can I get individual p-values and tests of changes in richness on the disturbance within each reef for benthic waters?
reefs <- benthic_meta_richness$site %>% unique %>% as.character()

betta_disturbance_results <- list()
global_p <- c()
for (i in 1:length(reefs)) {
  reefdata <- benthic_meta_richness %>% 
    filter(site == reefs[i])
  bt_disturbance_reef <- betta(formula = estimate ~ disturbance, 
                      ses = error, data = reefdata)
  bt_disturbance_reef_table <- bt_disturbance_reef$table
  betta_disturbance_results[[i]] <- bt_disturbance_reef_table
  pval <- bt_disturbance_reef$global[2]
  global_p <- rbind(global_p, pval)
}
names(betta_disturbance_results) <- reefs
```
From this, I can see that reefs harbor significantly different microbial richness and richness is significantly different across disturbance events, and across disturbance effects when accounting for the random effect of reef. 

### Surface - Does disturbance and reef influence alpha diversity?
```{r publication figures Alpha diversity surface}
## SURFACE DATA - USE Alpha diversity phyloseq object from last chunk
ps.a_surface <- ps %>%
  subset_samples(site != "Sand patch") %>%  # get rid of sandpatch
  subset_samples(depth == "Surface")        # only interested in benthic data

surface_richness <- ps.a_surface %>% breakaway        # estimate true richness

# Do inference on richness - I hypothesize that richness changes by reef and disturbance
surface_meta_richness <- ps.a_surface %>%
  sample_data %>%
  as_tibble %>%
  mutate("sample_names" = ps.a_surface %>% sample_names) %>%
  left_join(summary(surface_richness),
            by = "sample_names")

# Test the effect of Reef (site), disturbance, and disturbance with reef as a random effect
set.seed(100)
surf_bt_site_fixed <- betta(formula = estimate ~ site, 
                      ses = error, data = surface_meta_richness)
surf_bt_site_fixed$table
surf_bt_site_fixed$global[2] # get global p-value to see if there are changes across all reefs

surf_bt_disturbance_fixed <- betta(formula = estimate ~ disturbance, 
                      ses = error, data = surface_meta_richness)
surf_bt_disturbance_fixed$table
surf_bt_disturbance_fixed$global[2] # get global p-value to see if there are overall changes across disturbance

# Old way (still works) - check if the richness changes with disturbance within each reef site (adding in random effects)
surf_bt_disturbance_fixed_site_random <- betta_random(chats = surface_meta_richness$estimate,
                                       ses = surface_meta_richness$error,
                                       X = model.matrix(~ disturbance, data = surface_meta_richness),
                                       groups = surface_meta_richness$site)
surf_bt_disturbance_fixed_site_random$table
surf_bt_disturbance_fixed_site_random$global[2]

## Make graphs that display the different alpha diversity metrics:
e <- ggplot(surface_meta_richness, aes(x = disturbance, y = estimate)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7)+
  scale_color_brewer(palette = "Dark2") +
  labs(y = "Breakaway estimate of richness", x = "Disturbance", color = "Disturbance", 
       title = "Figure 5c. Surface richness") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# Graph disturbance and reef together
f <- ggplot(surface_meta_richness, aes(x = disturbance, y = estimate)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7)+
  facet_wrap(~ site, ncol = 8) +
  scale_color_brewer(palette = "Dark2") +
  labs(y = "Breakaway estimate of richness", x = "Disturbance", color = "Disturbance",
       title = "Figure S8 c. Surface microbial richness changes with disturbance") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        legend.position = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

# Can I get individual p-values and tests of changes in richness on the disturbance within each reef for benthic waters?
reefs <- surface_meta_richness$site %>% unique %>% as.character()

surface_betta_disturbance_results <- list()
surface_global_p <- c()
for (i in 1:length(reefs)) {
  reefdata <- surface_meta_richness %>% 
    filter(site == reefs[i])
  bt_disturbance_reef <- betta(formula = estimate ~ disturbance, 
                      ses = error, data = reefdata)
  bt_disturbance_reef_table <- bt_disturbance_reef$table
  surface_betta_disturbance_results[[i]] <- bt_disturbance_reef_table
  pval <- bt_disturbance_reef$global[2]
  global_p <- rbind(global_p, pval)
}
names(surface_betta_disturbance_results) <- reefs
```
From this, I can see that reefs harbor significantly different microbial richness in surface waters and richness is significantly different across disturbance events, and across disturbance effects when accounting for the random effect of reef. 


## Beta diversity

### Does depth influence beta diversity?

```{r publication figures beta diversity data prep and depth test}
sample_data(ps)$date <- as.Date(sample_data(ps)$date)
sample_data(ps)$site <- factor(sample_data(ps)$site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))
sample_data(ps)$disturbance <- factor(sample_data(ps)$disturbance, levels = c("historic", "hurricane", "disease"))
sample_data(ps)$depthtype <- factor(sample_data(ps)$depthtype, levels = c("benthic", "surface"))

# remove sand patch from dataset
ps.beta <- ps %>% subset_samples(site != "Sand patch")

# transform the data
ps.beta_clr <- microbiome::transform(ps.beta, 'clr')
ps.beta_clr_euc <- ordinate(ps.beta_clr, "RDA", "euclidean")

# plot PCA
betadepth <- plot_ordination(ps.beta_clr, ps.beta_clr_euc, 
                             type="samples", color="depthtype", shape = "disturbance") +
  coord_fixed() +
  geom_point(size = 3, alpha = 0.7) +
  labs(color = "Depth", shape = "Disturbance", title = "Figure S7 a. Beta diversity") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank())

# Do permanova (adonis test) to evaluate effect of reef and disturbance on composition.
clr_meta <- as(sample_data(ps.beta_clr), "data.frame")
clr_otu <- otu_table(ps.beta_clr) %>% as.matrix %>% t() #samples must be rows, so transpose

#get dissimilarity matrix 
euc_diss <- vegdist(clr_otu, method = "euclidean")

# permanova test to evaluate if depth is significantly structures microbial community beta diversity
set.seed(10)
adonis2(formula = euc_diss ~ depthtype, data = clr_meta, permutations = 999) 
```
From this, I conclude that depth is not a strong driver of changes in microbial community composition. I will proceed with analyses that combine both surface and benthic depth reef waters. 

### Does disturbance and reef influence beta diversity?
```{r beta diversity disturbance reef}
# Since it is not significantly different by depth, proceed by combining these together for the analyses:
# plot PCA showing reef and disturbance and disturbance nested within reef
betadisturbance <- plot_ordination(ps.beta_clr, ps.beta_clr_euc, type="samples", color= "disturbance") +
  coord_fixed() +
  scale_color_brewer(palette = "Dark2") +
  geom_point(size = 3, alpha = 0.7) +
  labs(color = "Disturbance", title = "Figure 5a. Beta diversity in benthic and surface reef water", ) +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank())

betareef <- plot_ordination(ps.beta_clr, ps.beta_clr_euc, type="samples", color = "disturbance") +
  coord_fixed() +
  facet_wrap(~ site, ncol = 8) +
  geom_point(size = 3, alpha =  0.7) +
  scale_color_brewer(palette = "Dark2") +
  labs(color = "Disturbance", title = "Figure S8 a. PCA on seawater microbial community faceted by reef") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        legend.position = "none")

# Does site and disturbance influence microbial community composition?
adonis2(formula = euc_diss ~ site, data = clr_meta, permutations = 999) 
adonis2(formula = euc_diss ~ disturbance, data = clr_meta, permutations = 999) 
adonis2(formula = euc_diss ~ site/disturbance, data = clr_meta, permutations = 999) #disturbance nested within site
```

# Figure 5 
Also associated alpha and beta diversity **supplementary graphs**
```{r diversity}
# Figure 5
# Microbial beta diversity, alpha diversity benthic, alpha diversity surface
ggarrange(betadisturbance, b, e, ncol = 3, labels = c("a.", "b.", "c."), common.legend = TRUE, widths = c(2,1,1))
#ggsave("figures/Alpha_Beta_Diversity_disturbance.pdf", width = 7.5, height = 4)

# Supplementary Figure S7
# Microbial beta diversity, alpha diversity depth tests and results
ggarrange(betadepth, alphadepth, ncol = 2, labels = c("a.", "b."), common.legend = TRUE, widths = c(2,1))

# Supplementary Figure S8
# Microbial alpha and beta diversity across disturbbances within individual reefs
ggarrange(betareef, c, f, nrow = 3, labels = c("a.", "b.", "c."), 
          common.legend = TRUE)
```

# Differential Abundance 
### Load data
```{r}
# Prep the phyloseq object
sample_data(ps)$date <- as.Date(sample_data(ps)$date)
sample_data(ps)$site <- factor(sample_data(ps)$site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))
sample_data(ps)$disturbance <- factor(sample_data(ps)$disturbance, levels = c("historic", "hurricane", "disease"))

# BENTHIC DATA
ps.benthic <- ps %>% 
  subset_samples(site != "Sand patch") %>%
  subset_samples(depth == "Benthic")

# test differential abundance between all 3 timepoints, then just between hurricane and disease
ps.benthic.disturbances <- ps.benthic %>% 
  subset_samples(disturbance %in% c("hurricane", "disease"))

# Try renaming all the NA taxa using the fantaxtic package Natasha sent me
ps.benthic.disturbances <- name_na_taxa(ps.benthic.disturbances, 
                                        na_label = "Unclassified <tax> (<rank>)")
ps.benthic <- name_na_taxa(ps.benthic, 
                           na_label = "Unclassified <tax> (<rank>)")
```


### Benthic community

```{r disturbance benthic, message=FALSE}
# What microorganisms are significantly changing across disturbances? Reef and timpoint are important covariates too, so control for the effect of reef site and month year timepoint abundance and dispersion
# Note historic is the control so plots will show hurricane and diseae relative to that timepoint
set.seed(1)
disturbance.da <- differentialTest(formula = ~ disturbance + site, 
                             phi.formula = ~ disturbance + site,
                             formula_null = ~ site,
                             phi.formula_null = ~ disturbance + site,
                             test = "Wald", boot = FALSE,
                             data = ps.benthic,
                             fdr_cutoff = 0.05)

# What microorganisms are significantly changing between hurricane and disease disturbances? Reef and timpoint are important covariates too, so control for the effect of reef site and month year timepoint abundance and dispersion
# Note historic is the control so plots will show hurricane and diseae relative to that timepoint
set.seed(1)
hurr.sctld.da <- differentialTest(formula = ~ disturbance + site, 
                             phi.formula = ~ disturbance + site,
                             formula_null = ~ site,
                             phi.formula_null = ~ disturbance + site,
                             test = "Wald", boot = FALSE,
                             data = ps.benthic.disturbances,
                             fdr_cutoff = 0.05)


# save the disturbance.da output and add asv, p.adj values to it, and ultimately taxonomny info
dist.da.models <- lapply(disturbance.da$significant_models, extractmods1)
names(dist.da.models) <- disturbance.da$significant_taxa

# Add ASVs to the taxonomy table and save the significant asvs
tax_table(ps.benthic)[,7] <- rownames(tax_table(ps.benthic))
sig.taxonomy <- as.data.frame(tax_table(ps.benthic)[disturbance.da$significant_taxa,]) 

# Move the data from a list to a dataframe and add taxonomy info
dist.da.models.df <- ldply(dist.da.models, data.frame) %>% 
  mutate(test = rep(c("disturbancehurricane", "disturbancedisease"), times = 354/2)) %>% 
  left_join(sig.taxonomy, by = c(".id" = "Species")) %>%
  mutate(genusasv = paste0(Genus, "_(", .id,")"))

## hurr.sctld.da output ##

# save the disturbance.da output and add asv, p.adj values to it, and ultimately taxonomny info
hurr.sctld.da.models <- lapply(hurr.sctld.da$significant_models, extractmods2)
names(hurr.sctld.da.models) <- hurr.sctld.da$significant_taxa

# Add ASVs to the taxonomy table and save the significant asvs
tax_table(ps.benthic.disturbances)[,7] <- rownames(tax_table(ps.benthic.disturbances))
sig.taxonomy2 <- as.data.frame(tax_table(ps.benthic.disturbances)[hurr.sctld.da$significant_taxa,]) 

# Move the data from a list to a dataframe and add taxonomy info
hurr.sctld.da.models.df <- ldply(hurr.sctld.da.models, data.frame) %>%
  mutate(test = rep("hurricanedisease")) %>% 
  left_join(sig.taxonomy2, by = c(".id" = "Species")) %>%
  mutate(genusasv = paste0(Genus, "_(", .id,")"))

# Add the data together, sort by ASV, then save
allresults <- rbind(dist.da.models.df, hurr.sctld.da.models.df) %>%
  arrange(.id, test) %>%
  mutate(coefNOTzero = Estimate + Std.Error >= 0 & Estimate - Std.Error >= 0 | Estimate + Std.Error <= 0 & Estimate - Std.Error <= 0) %>%
  mutate(coefABOVEtwo = abs(Estimate) > 2) %>%
  mutate(coefABOVEone = abs(Estimate) > 1)

### Save these data so you don't have to re-run the model ###
# write.table(allresults, "data/Sig_ASVs_Disturbance_Feb23.txt", sep="\t",row.names = FALSE)
```
So I saved the output of all the ASVs that were differentially enriched or depleted between the following conditions:
historic disturbance and hurricane (historic is baseline)
historic disturbacne and disease (historic is baseline)
hurricane and disease (hurricane is baseline)

### What are the taxonomic assignments of differentially abundant taxa?

```{r Corncob_results, message=FALSE, warning=FALSE}
DAdisturbance <- read_delim("data/Sig_ASVs_Disturbance_Feb23.txt", delim = "\t", col_names = TRUE)

# remove all FALSE asvs - these are ones where the coeficient passes through zero with the standard error and I'd rather not graph those
DA_nozero <- DAdisturbance %>%
  filter(coefNOTzero == TRUE)

# how many differentially abundant ASVs - ~200!
DA_nozero$.id %>% unique %>% length


DAresults <- DA_nozero %>% 
  dplyr::select(.id, Estimate, test, Kingdom, Class, Order, Family, genusasv) %>%
  arrange(desc(Class), Estimate)

kable(DAresults)
```

# Random Forest Analysis
```{r}
# adjust levels for random forest analysis
sample_data(ps)$disturbance <- factor(sample_data(ps)$disturbance, levels = c("historic", "hurricane", "disease"))

# Try renaming all the NA taxa using the fantaxtic package Natasha sent me
ps.RF <- name_na_taxa(ps, na_label = "Unclassified <tax> (<rank>)")

# BENTHIC FILTERED data (~1000 taxa)
ps.benthicfilt <- ps.RF %>% 
  subset_samples(site != "Sand patch") %>%
  subset_samples(depth == "Benthic") %>%
  filter_taxa(function(x) mean(x) > 0.5, TRUE) # keep if avg abundance 0.5 counts

taxa <- ps.benthicfilt %>% tax_table() %>% rownames

# Get surface taxa based on the asvs in the benthic seawater - This will be for validation of the random forest model
ps.surfacefilt <- ps %>% 
  subset_samples(site != "Sand patch") %>%
  subset_samples(depth == "Surface") %>%
  mutate_tax_table(ASV = .otu) %>% 
  subset_taxa(ASV %in% taxa)
```

## Generate and test random forest model
```{r RF model}
## RANDOM FOREST ANALYSIS ##
# get the ASVs as columns and samples as rows, which are the predictors
predictors <- t(otu_table(ps.benthicfilt))

# response variable is the disturbance groups
response <- as.factor(sample_data(ps.benthicfilt)$disturbance)

# combine with the ASV table
resp.pred <- data.frame(response, predictors)

# set seed for reproducibility and this is the main random forest model
set.seed(10)
disturbance.classify <- randomForest(response ~ ., data = resp.pred, ntree = 1000, importance = TRUE)
print(disturbance.classify)

# Validate the model on surface data
validation <- t(otu_table(ps.surfacefilt))

response <- as.factor(sample_data(ps.surfacefilt)$disturbance)

valid.resp <- data.frame(response, validation)

# Validation set assessment #1: looking at confusion matrix
prediction_for_table <- predict(disturbance.classify, valid.resp[,-1])

table(observed = valid.resp[,1], predicted = prediction_for_table)
```

## Save Random Forest data output
```{r}
# make a data frame with predictor names and the importance value
imp <- importance(disturbance.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# order the predictor levels by importance (higher number is more important)
imp.sort.Accuracy <- arrange(imp, desc(MeanDecreaseAccuracy))

# Select the top 50 important taxa based on the Mean Decrease Accurracy metric
imp.50.acc <- imp.sort.Accuracy[1:50,]

# Save a table of the top 50 ASVs
ASV.50.acc <- imp.50.acc$predictors
r <- rownames(tax_table(ps.benthicfilt)) %in% ASV.50.acc
table <- tax_table(ps.benthicfilt)[r,]

table <- as.data.frame(table)
table$ASV <- rownames(table)

tableAccuracy <- left_join(table, imp.50.acc, by = c("ASV" = "predictors"))

# write.table(tableAccuracy, "data/RandomForest_disturbance_top50_accuracy_benthic.txt", sep = "\t", row.names = FALSE)

kable(table)
```

# Figure 6
```{r message=FALSE}
DAtaxa <- read_delim("data/Sig_ASVs_Disturbance_Feb23.txt", delim = "\t", col_names = TRUE)

RFtaxa <- read_delim("data/RandomForest_disturbance_top50_accuracy_benthic.txt", delim = "\t", col_names = TRUE)

# adjust levels on the phyloseq object
sample_data(ps)$site <- factor(sample_data(ps)$site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))
sample_data(ps)$disturbance <- factor(sample_data(ps)$disturbance, levels = c("historic", "hurricane", "disease"))

# Try renaming all the NA taxa using the fantaxtic package Natasha sent me
ps.fig6 <- name_na_taxa(ps, na_label = "Unclassified <tax> (<rank>)")

ps.benthic <- ps.fig6 %>% 
  subset_samples(site != "Sand patch") %>%      # remove sand patch samples
  subset_samples(depth == "Benthic") %>%        # only focus on benthic samples
  mutate_tax_table(ASV = .otu)                  # add ASV/otu column
```

How many ASVs are shared?
```{r}
RFasvs <- RFtaxa %>% 
  dplyr::select(ASV, MeanDecreaseAccuracy)

shared <- DAtaxa %>%
  left_join(RFasvs, by = c(".id" = "ASV")) %>%
  drop_na(MeanDecreaseAccuracy) %>% 
  filter(coefNOTzero == "TRUE") # remove taxa that cross zero in differential abundnatce test

# how many ASVs?
shared$.id %>% unique %>% length
```

Make a table of shared taxa
```{r}
importantASVs <- shared$.id %>% unique

r <- rownames(tax_table(ps.benthic)) %in% importantASVs

sharedtaxa <- as.data.frame(tax_table(ps.benthic)[r,])
```

Make the shared graph
```{r}
# corncob results
# order the taxa how i want them in the plot, with the archaea at the bottom
genusASVorder <- shared %>%
  arrange(Kingdom, desc(Class), Estimate) %>%
  dplyr::select(genusasv) %>%
  unique() 

shared$genusasv <- factor(shared$genusasv, levels = as.vector(genusASVorder$genusasv))
shared$test <- factor(shared$test, levels = c("disturbancehurricane", "disturbancedisease", "hurricanedisease"))
shared$Class <- factor(shared$Class, levels = c("Alphaproteobacteria", "Bacteroidia", "Bdellovibrionia",
                                                "Cyanobacteriia", "Dehalococcoidia", 
                                                "Gammaproteobacteria", 
                                                "Unclassified Marinimicrobia (SAR406 clade) (Phylum)",
                                                "Unclassified SAR324 clade(Marine group B) (Phylum)",
                                                "Verrucomicrobiae", 
                                                "Thermoplasmata"))


palcolors <- c("#CC7A88", "#99600F", "#CCAA7A", "#54990F", "#3D0F99", "#967ACC","#0F8299",  "#7ABECC", "#333333", "#999999")

a <- ggplot(shared, aes(x = genusasv, y = Estimate, color = Class)) +
  geom_errorbar(aes(ymin = Estimate-Std.Error, ymax = Estimate+Std.Error), color = "black", width = .3, position=position_dodge(.9)) +
  geom_point(size = 4) +
  coord_flip() +
  theme_bw() +
  labs(x = "Taxa", y = "Coefficient from differential abundance test") +
  facet_wrap(~ test) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "darkgray") +
  theme(plot.background = element_blank(), 
        legend.position = "bottom") +
  scale_color_manual(values = palcolors)

b <- ggplot(shared, aes(x = genusasv, y = MeanDecreaseAccuracy, fill = Class)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_manual(values = palcolors) +
  theme(plot.background = element_blank()) +
  labs(x = "Taxa", y = "Mean decrease accuracy") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")

wrap_plots(a, b, widths = c(3,1))

#ggsave("figures/DA_RFaccuracy_shared_3.15.23.pdf", width = 11, height = 7)
```

# Supplementary Figure S5 - temperature
```{r temp, results = 'hide', message = FALSE}
# hobo and lameshur bay data from NOAA
tempwlam <- multiplesheets(temperaturepath)

tempwlamdf <- ldply(tempwlam, data.frame, .id = "reef") %>%
  filter(reef != "buoy41052") %>%
 mutate(reefname = case_when(reef == "lamv3" ~ "LameshurBay_NOAA",
                             reef == "BR" ~ "Booby Rock", 
                             reef == "CO" ~ "Cocoloba",
                             reef == "DL" ~ "Dittlif",
                             reef == "DP" ~ "Dittlif",
                             reef == "EU" ~ "Europa",
                             reef == "JS" ~ "Joels Shoal",
                             reef == "RB" ~ "Sand patch",
                             reef == "RH" ~ "Ram Head",
                             reef == "TK" ~ "Tektite",
                             reef == "YZ" ~ "Yawzi",
                             ))

tempwlamdf$Time <- as.POSIXct(tempwlamdf$Time, tz = "", format = "%Y/%m/%d %H:%M")
```


```{r temp2}
trendline <- lm(temperature_daily_mean_C ~ Time, data = tempwlamdf)
summary(trendline)

ggplot(tempwlamdf, aes(x = Time, y = temperature_daily_mean_C)) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-09-06")), colour = "darkred", linewidth = 4) + # hurricane
  geom_vline(xintercept = as.POSIXct(as.Date("2020-06-01")), colour = "darkred", linewidth = 4) + # disease emergence
  geom_vline(xintercept = as.POSIXct(as.Date("2016-06-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2016-10-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-03-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-07-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-11-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2018-04-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2018-11-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2020-08-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2021-01-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2021-10-01")), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.POSIXct(as.Date("2022-06-01")), colour = "gray", linewidth = 2) +
  geom_line(data = tempwlamdf, aes(color = reefname, group = format(Time, "%Y-%m"))) +
  stat_poly_line(method = "lm") +
  stat_poly_eq(aes(label = after_stat(eq.label)), label.x = as.Date("2022-01-01")) +
  scale_color_carto_d(palette = "Bold") +
  labs(y = "Mean daily temperature (Celsius)", title = "Figure S5. Temperature at reef depth over seven years", color = "Site")

#ggsave("figures/Temp_in_situ.png", width = 8, height = 5, dpi = "retina")
```

# Supplementary Figures S9-11
```{r}
# Shared is from the section on "How many ASVs were shared?"
# prep the data
ASVshared <- shared %>%
  dplyr::select(.id) %>%
  unique()

ASVshared <- ASVshared$.id # must be a vector

ps.shared.ra <- ps.benthic %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  subset_taxa(ASV %in% ASVshared) 

ASVorder <- shared %>%
  arrange(Kingdom, desc(Class), Estimate) %>%
  dplyr::select(.id) %>%
  unique()

# plot relative abundance data
shared.ra.long <- ps.shared.ra %>%
  otu_table() %>%
  as_tibble() %>%
  left_join(as_tibble(tax_table(ps.shared.ra)), by = ".otu") %>%
  left_join(as_tibble(sample_data(ps.shared.ra)), by = ".sample") %>%
  mutate(genusasv = paste0(Genus, "_(", .otu, ")")) %>%
  mutate(.otu = factor(.otu, levels = as.vector(ASVorder$.id))) %>%
  mutate(genusasv = factor(genusasv, levels = as.vector(genusASVorder$genusasv))) %>% 
  mutate(Class = factor(Class, levels = c("Alphaproteobacteria", "Bacteroidia", "Bdellovibrionia",
                                                "Cyanobacteriia", "Dehalococcoidia", 
                                                "Gammaproteobacteria", 
                                                "Unclassified Marinimicrobia (SAR406 clade) (Phylum)",
                                                "Unclassified SAR324 clade(Marine group B) (Phylum)",
                                                "Verrucomicrobiae", 
                                                "Thermoplasmata")))

# remove bacteroidia and cyanobacteriia
nobactcyano <- shared.ra.long %>% 
  filter(Class != "Bacteroidia") %>% 
  filter(Class != "Cyanobacteriia")

ggplot(nobactcyano, aes(x = disturbance, y = .abundance)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7)+
  facet_wrap(~ Class + genusasv, ncol = 4, scales = "free_y") +
  labs(y = "Relative abundance", x = "Disturbance", color = "Disturbance", title = "Figure S9") +
  scale_color_brewer(palette = "Dark2") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        legend.position = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))


# PLot the differentially abunant bacteroidia
Bacters <- shared.ra.long %>%
  filter(Class == "Bacteroidia") %>%
  mutate(date = as.Date(date)) 

Bacters$genusasv <- factor(Bacters$genusasv, levels = c("NS5 marine group_(ASV100)",
                                               "NS5 marine group_(ASV59)",
                                               "NS5 marine group_(ASV273)",
                                               "NS4 marine group_(ASV14)",
                                               "Tenacibaculum_(ASV268)",
                                               "Unclassified Cryomorphaceae (Family)_(ASV187)"))

ggplot(Bacters, aes(x = disturbance, y = .abundance)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7)+
  facet_wrap(~ genusasv, ncol = 3, scales = "free_y") +
  labs(y = "Relative abundance", x = "Disturbance", color = "Genus", title = "Figure S10. Bacteroidia significantly changed with disturbances") +
  scale_color_brewer(palette = "Dark2") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))


# Plot the differentially abundant cyanobacteria
cyanos <- shared.ra.long %>%
  filter(Class == "Cyanobacteriia") %>%
  mutate(date = as.Date(date)) 

cyanos$genusasv <- factor(cyanos$genusasv, levels = c("Synechococcus CC9902_(ASV44)",
                                               "Synechococcus CC9902_(ASV140)",
                                               "Synechococcus CC9902_(ASV248)",
                                               "Synechococcus CC9902_(ASV24)",
                                               "Prochlorococcus MIT9313_(ASV2)",
                                               "Prochlorococcus MIT9313_(ASV15)",
                                               "Unclassified Cyanobiaceae (Family)_(ASV106)"))

ggplot(cyanos, aes(x = disturbance, y = .abundance)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7)+
  facet_wrap(~ genusasv, ncol = 4, scales = "free_y") +
  labs(y = "Relative abundance", x = "Disturbance", color = "Genus", title = "Figure S11. Cyanobacteria significantly changed with disturbances") +
  scale_color_brewer(palette = "Dark2") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))

```

# Supplementary Figure S12 - Precipitation
```{r}
precip2016to2022 <- precip %>% 
  mutate(DATE =  as.Date(DATE, "%Y-%m-%d")) %>%
  filter(between(DATE, as.Date("2016-01-15"), as.Date("2022-12-15")))

ggplot(precip2016to2022, aes(x = DATE, y = PRCP)) +
  geom_vline(xintercept = as.Date("2017-09-06"), colour = "darkred", linewidth = 4, alpha = 0.8) + # hurricane
  geom_vline(xintercept = as.Date("2020-06-01"), colour = "darkred", linewidth = 4, alpha = 0.8) + # disease emergence
  geom_vline(xintercept = as.Date("2016-06-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2016-10-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2017-03-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2017-07-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2017-11-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2018-04-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2018-11-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2020-08-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2021-01-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2021-10-01"), colour = "gray", linewidth = 2) +
  geom_vline(xintercept = as.Date("2022-06-01"), colour = "gray", linewidth = 2) +
  geom_line(color = "darkblue", linewidth = 1.5) +
  labs(x = "Date", y = "Precipitation", title = "Figure S12. Monthly precipitation at East End, US Virgin Islands")
```


# Bonus Supplementary Figures - Not referenced in the text
```{r extra_supplementary_figs}
benthic.forFigures <- env.long.olrm %>%
  filter(datatype %in% benthic_vars) %>%
  drop_na(value) %>%
  mutate(datatype = factor(datatype, levels = 
                             c("Ramicrusta","TurfAlgae","Macroalgae","HardCoral","SoftCoral")))
# faceted by reef
ggplot(benthic.forFigures, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance), size = 3, alpha = 0.7) +
  labs(y = "Relative cover", x = "Disturbance event", color = "Disturbance", title = "Supplementary Figure S14") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_grid(datatype ~ site, scales = "free_y")

# all values over time (color by reef)
ggplot(benthic.forFigures, aes(x = Date, y = value, color = site)) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-09-06")), colour = "gray", linewidth = 3) + # Irma and Maria
  geom_vline(xintercept = as.POSIXct(as.Date("2020-06-01")), colour = "gray", linewidth = 3) + # Bleaching event
  geom_point(aes(shape = disturbance), data = benthic.forFigures, size = 4, alpha = 0.8) +
  geom_line(linewidth = 1.2) +
  scale_color_carto_d(palette = "Safe") +
  facet_wrap( ~ datatype, scales = "free_y", ncol = 3) +
  labs(y = "Relative cover", x = "Date", color = "Reef", shape = "Disturbance", title = "Supplementary Figure S15")

nuts.forFigures <- env.long.olrm %>%
  filter(datatype %in% nuts_vars) %>%
  drop_na(value) %>%
  mutate(datatype = factor(datatype, levels = c("nh4_um","TON","Chl_ug_per_l","po4_um","silicate_um", "npoc_um","no2_um", "no3_um")))

# faceted by reef
ggplot(nuts.forFigures, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance, shape = depthtype), size = 3, alpha = 0.7) +
  labs(y = "Concentration", x = "Disturbance event", color = "Disturbance", title = "Supplementary Figure S16") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_grid(datatype ~ site, scales = "free_y")

# all values over time (color by reef)
ggplot(nuts.forFigures, aes(x = Date, y = value, color = site)) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-09-06")), colour = "gray", linewidth = 3) + # Irma and Maria
  geom_vline(xintercept = as.POSIXct(as.Date("2020-06-01")), colour = "gray", linewidth = 3) + # Bleaching event
  geom_point(aes(shape = depthtype), data = nuts.forFigures, size = 4, alpha = 0.8) +
  geom_line(linewidth = 1.2) +
  scale_color_carto_d(palette = "Safe") +
  facet_wrap( ~ datatype, scales = "free_y", ncol = 4) +
  ggtitle("Supplementary Figure S17")

cells.forFigures <- env.long.olrm %>%
  filter(datatype %in% cells_vars) %>%
  drop_na(value) %>%
  mutate(datatype = factor(datatype, levels = c("pro_per_ml","peuk_per_ml","syn_per_ml","hbact_per_ml","biomassRatio")))

# faceted by reef
ggplot(cells.forFigures, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(colour = disturbance, shape = depthtype), size = 3, alpha = 0.7) +
  labs(y = "Abundance (cells per milliliter)", x = "Disturbance event", color = "Disturbance", title = "Supplementary Figure S18") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_grid(datatype ~ site, scales = "free_y")

# all values over time (color by reef)
ggplot(cells.forFigures, aes(x = Date, y = value, color = site)) +
  geom_vline(xintercept = as.POSIXct(as.Date("2017-09-06")), colour = "gray", linewidth = 3) + # Irma and Maria
  geom_vline(xintercept = as.POSIXct(as.Date("2020-06-01")), colour = "gray", linewidth = 3) + # Bleaching event
  geom_point(aes(shape = depthtype), data = cells.forFigures, size = 4, alpha = 0.8) +
  geom_line(linewidth = 1.2) +
  scale_color_carto_d(palette = "Safe") +
  facet_wrap( ~ datatype, scales = "free_y", ncol = 3) +
  labs(y = "Abundance (cells per milliliter)", shape = "Depth", color = "Reef", title = "Supplementary Figure S19") 
```

# Figures and Analyses for paper revision

## Try accounting for sampling site and sampling timepoint in the disturbance analysis for environmental data. 
### First Hard Coral to test
```{r}
# Use the data from the ## ANOVA or Kruskal Wallis tests section
env.data.foranalysis

# make sure reef site and yearmonth are factors with levels
env.data.foranalysis <- env.data.foranalysis %>%
  mutate(yearmonth = factor(yearmonth, levels = c("2016-06", "2016-10", "2017-03", "2017-07", "2017-11", "2018-04", "2018-11", "2020-08", "2021-01", "2021-10", "2022-06")))

# test on one variable first, before going through lots of them
coral.data <- filter(env.data.foranalysis, datatype == "HardCoral")

# use a linear mixed-effects model (LMM) to examine the impact of disturbance on hard coral on reefs. Use this model to account for any random effects due to site-based differences in coral cover and random effects associated with the sampling timepoint ("yearmonth"). 
coral_model <- lme4::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = coral.data)

# now lets look at the model
summary(coral_model)

# check model assumptions that residuals are normally distributed 4 ways. 
  ## 1) plot residuals against predicted values
  ## 2) rough normality check (qq plot)
  ## 3) check variance constant across range of values by looking at the distribution of residuals
  ## 4) spot outliers

pred.coral <- predict(coral_model)
res.coral <- residuals(coral_model)
res.pred.model <- data.frame(pred.coral, res.coral, coral.data)

plot(x = pred.coral, y = res.coral)
abline(h = 0)

qqnorm(res.coral) # surprisingly looks pretty good! 
hist(res.coral)

# compare residual variances across groups (fixed and random effect groups) to check homogeneity of variance
ggplot(res.pred.model, aes(x = pred.coral, y = res.coral, color = disturbance)) +
  geom_point() +
  geom_hline(yintercept = 0)
ggplot(res.pred.model, aes(x = pred.coral, y = res.coral, color = disturbance)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  facet_wrap(. ~ disturbance)
ggplot(res.pred.model, aes(x = pred.coral, y = res.coral, color = site)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  facet_wrap(. ~ site)
ggplot(res.pred.model, aes(x = pred.coral, y = res.coral, color = yearmonth)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  facet_wrap(. ~ yearmonth)
# Overall, my takeaway is that this model meets assumptions. The residuals overall are normally distributed. Additionally, the variance of the residuals is pretty consistent visually across the different fixed and random effects groups

# Does adding in timpoint as a random effect to control for any variance due to timepoint make a stronger model? Compare two models, one without timepoint random effect

coral_model_notime <- lme4::lmer(value ~ disturbance + (1|site), data = coral.data)
summary(coral_model_notime)

# I now have two models. One incorporates timepoint as a random effect, and one that only includes site as a random effect. Both investigate the change due to disturbance. 
# I can use a likelihood ratio test with the anova function to examine which model is better
anova(coral_model, coral_model_notime)

# I can see that in the coral_model, where we added 1 parameter (random effect of yearmonth), there was a very small p value, which means the fit is SO much better than with only accounting for a random effect of site. This leads me to believe that doing a test in which i incorporate random effect of site AND timepoint, will lead to better fit of the model. I will keep including timepoint as a random effect.

# What about including site or not?
coral_model_nosite <- lme4::lmer(value ~ disturbance + (1|yearmonth), data = coral.data)
summary(coral_model_nosite)

anova(coral_model, coral_model_nosite)
# I can see that the model in which I add site as a random effect leads to an improvement of the fit of the model over only including a random effect for yearmonth. This is based on the small p-value associated with the chisq statistic. 
# I conclude that I will include both site and yearmonth as fixed effects in the model. 


## I now have a model I like (coral_model) and the model assumptions are adequately met. 

## Next step - compute confidence intervals (better than just standard error bars) and a p value (realistically, my reviewers will want this). Putting 95% confidence intervals on the graphs will be better and show the differences. 

confint.merMod(coral_model)

# Plot the predictions for coral cover across different disturbances
ggplot(res.pred.model, aes(x = disturbance, y = pred.coral, color = site)) +
  geom_point()
# plot the actual - look how much variance we removed by doing the model!
ggplot(res.pred.model, aes(x = disturbance, y = value, color = site)) +
  geom_point()

# Get p-values for the graphs
#install.packages("afex")
library(afex); packageVersion("afex")

coral_model_p <- mixed(value ~ disturbance + (1|site) + (1|yearmonth), data = coral.data, method = "KR", check_contrasts = TRUE)
coral_model_p
summary(coral_model_p)

confint(coral_model)

#install.packages("ciTools")
library(ciTools)

summary(coral_model)
add_ci(coral.data, coral_model, alpha = 0.05, type = "parametric")


coral_null <- lme4::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = coral.data)
coral_null

# Use likelihood ratio test to compare the null to the actual model
anova(coral_null, coral_model)

# When I compare whether disturbance had a significant impact on coral cover, I find that disturbance did not impact coral cover (X^2(1)=3.55, p=0.1697), and if it were signficant I could state how much it increased or decreased. 


```

### Next ammonium to test
```{r}
# Use the data from the ## ANOVA or Kruskal Wallis tests section
env.data.foranalysis

# test on one variable first, before going through lots of them
nh4.data <- filter(env.data.foranalysis, datatype == "nh4_um")

# use a linear mixed-effects model (LMM) to examine the impact of disturbance on ammonium on reefs. Use this model to account for any random effects due to site-based differences in coral cover and random effects associated with the sampling timepoint ("yearmonth"). 
nh4_model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = nh4.data)

# now lets look at the model
summary(nh4_model)

# check model assumptions that residuals are normally distributed 4 ways. 
  ## 1) plot residuals against predicted values
  ## 2) rough normality check (qq plot)
  ## 3) check variance constant across range of values by looking at the distribution of residuals
  ## 4) spot outliers

pred.nh4 <- predict(nh4_model)
res.nh4 <- residuals(nh4_model)
res.pred.model.nh4 <- data.frame(pred.nh4, res.nh4, nh4.data)

variable <- "ammonium"

par(mfrow=c(2,2))
plot(x = pred.nh4, y = res.nh4)
abline(h = 0)
qqnorm(res.nh4) 
hist(res.nh4)
plot.new()
text(0.5,0.5, paste(variable), cex=2)

# compare residual variances across groups (fixed and random effect groups) to check homogeneity of variance
ggplot(res.pred.model.nh4, aes(x = pred.nh4, y = res.nh4, color = disturbance)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  ggtitle(paste(variable))
ggplot(res.pred.model.nh4, aes(x = pred.nh4, y = res.nh4, color = disturbance)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  facet_wrap(. ~ disturbance) +
  ggtitle(paste(variable))
ggplot(res.pred.model.nh4, aes(x = pred.nh4, y = res.nh4, color = site)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  facet_wrap(. ~ site)+
  ggtitle(paste(variable))
ggplot(res.pred.model.nh4, aes(x = pred.nh4, y = res.nh4, color = yearmonth)) +
  geom_point() +
  geom_hline(yintercept = 0) +
  facet_wrap(. ~ yearmonth)+
  ggtitle(paste(variable))
# Overall, my takeaway is that this model meets assumptions. 

# Does adding in timepoint and site as a random effect to control for any variance due to timepoint make a stronger model? Use the likelihood ratio test to compare the models with and without those random effects. 

# make models with only one random effect
nh4_model_notime <- lmerTest::lmer(value ~ disturbance + (1|site), data = nh4.data)
nh4_model_nosite <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = nh4.data)

# Use the likelihood ratio test to compare the models to the full model. If the full model is an imporvement, use it. 
timeeval <- anova(nh4_model, nh4_model_notime)
timeeval_p <- timeeval$`Pr(>Chisq)`[2]
siteeval <- anova(nh4_model, nh4_model_nosite)
siteeval_p <- siteeval$`Pr(>Chisq)`[2]

# Looks like adding site is irrelevant but timepoint (yearmonth) is important for a better fit of the model.

## I now have a model I am ok with (nh4_model) and the model assumptions are adequately met. 

## Next step - answer the question, does disturbance itself signficantly impact ammonium on reefs. Use a likelihood ratio test comparing two models. One in which disturbance is used as a covariate to explain changes in ammonium, and one where it is not included. 
nh4_null <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = nh4.data)

# Use likelihood ratio test to compare the null to the actual model
disturbance_result <- anova(nh4_null, nh4_model)
disturbance_result_report <- disturbance_result[2,6:8]

# When I compare whether disturbance had a significant impact on ammonium, I find that disturbance DID impact ammonium (X^2(1)=7.1882, p=0.02749), increasing ammonium by 0.145 uM during the post-hurricane period and increasing 0.203 uM during the disease outbreak.

# Next just have in the background the comparison of predicted vs. actual values as plots
# Plot the predictions for coral cover across different disturbances
predicted <- ggplot(res.pred.model.nh4, aes(x = disturbance, y = pred.nh4)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7) +
  scale_color_brewer(palette = "Dark2") 
# plot the actual - look how much variance we removed by doing the model!
actual <- ggplot(res.pred.model.nh4, aes(x = disturbance, y = value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7) +
  scale_color_brewer(palette = "Dark2") 

ggarrange(predicted, actual, ncol = 2, labels = c(paste("Predicted", variable), paste("Actual", variable)), common.legend = TRUE, widths = c(1,1))

## Next step - compute confidence intervals (better than just standard error bars) and a p value (realistically, my reviewers will want this). Putting 95% confidence intervals on the graphs will be better and show the differences. Ignore the (intercept) part because that is the baseline, and refers to the historic grouping. In the fixed effects of the summary output, the estimates represent how much HIGHER (or lower) the value is compared to the intercept.

# PLot the estimates and their confidence intervals. If they don't pass through zero, that is usually a good indicator that they significantly changed. 
fe <- fixef(nh4_model)
ci <- confint(nh4_model)

cife <- data.frame(ci[4:6,], fe, "disturbance" = c("historic", "hurricane", "disease"))
colnames(cife) <- c("lower", "upper", "fixedeff", "disturbance")
cife$disturbance <- factor(cife$disturbance, levels = c("historic", "hurricane", "disease"))

cife_noIntercept <- cife[2:3,]

# Plot the coefficients for ammonium across different disturbances with the confidence intervals. Since they don't go through zero that is a good indicator that it will be significant. But I will double check this. 
ggplot(cife_noIntercept, aes(x = disturbance, y = fixedeff, color = disturbance)) +
  geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
  geom_point(size = 5) +
  geom_errorbar(data = cife_noIntercept, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
  scale_color_manual(values = c("#D95F02", "#7570B3")) +
  labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic", title = paste(variable))
```

# REVISION FIGs Disturbance Shifts in environmental parameters - LMM approach

Goal - Use a linear mixed effects modeling approach to investigate the impact that disturbances have on environmental parameters of interest. 
Do this all in a for loop
```{r}
env.data.foranalysis

variables <- as.vector(unique(env.data.foranalysis$datatype))

# Initialize an empty list to store results
results_list <- list()
CI_list <- list()
  
for (i in 1:length(variables)) {
  cat("Variable:", variables[i], "\n")
  
  envdata <- filter(env.data.foranalysis, datatype == variables[i])
  
  model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)
  
  cat("Summary of Model for", variables[i], "\n")
  print(summary(model))
  
  # save the predicted and raw values
  pred <- predict(model)
  res <- residuals(model)
  res.pred.data <- data.frame(pred, res, envdata)
  
  var <- variables[i]
  
  # Open a PDF file for saving plots
  pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
  par(mfrow=c(2,2))
  plot(x = pred, y = res)
  abline(h = 0)
  qqnorm(res) 
  hist(res)
  plot.new()
  text(0.5,0.5, paste(var), cex=2)
  
  # Close the PDF file
  dev.off()
  
  p1 <- ggplot(res.pred.data, aes(x = pred, y = res, color = disturbance)) +
    geom_point() +
    geom_hline(yintercept = 0) +
    facet_wrap(. ~ disturbance) +
    ggtitle(paste(var))
  
  p2 <- ggplot(res.pred.data, aes(x = pred, y = res, color = site)) +
    geom_point() +
    geom_hline(yintercept = 0) +
    facet_wrap(. ~ site) +
    ggtitle(paste(var))
  
  p3 <- ggplot(res.pred.data, aes(x = pred, y = res, color = yearmonth)) +
    geom_point() +
    geom_hline(yintercept = 0) +
    facet_wrap(. ~ yearmonth) +
    ggtitle(paste(var))
  
  ggsave(paste("figures/lmer_figs/", var, "_assumptions_disturb.pdf", sep = ""), plot = p1)
  ggsave(paste("figures/lmer_figs/", var, "_assumptions_site.pdf", sep = ""), plot = p2)
  ggsave(paste("figures/lmer_figs/", var, "_assumptions_yearmonth.pdf", sep = ""), plot = p3)
  
  # Make models with and without the random effects and a null model without disturbance as fixed effect
  notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata)
  nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata)
  null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
  time_LRT <- anova(model, notime_model)
  site_LRT <- anova(model, nosite_model)
  disturbance_LRT <- anova(model, null_model)
  
  # Save graphs of both the predicted and actual values just out of interest
  predicted <- ggplot(res.pred.data, aes(x = disturbance, y = pred)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Dark2") 
  actual <- ggplot(res.pred.data, aes(x = disturbance, y = value)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(position = position_jitter(width=.1, height=0), aes(color = disturbance), size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Dark2") 
  
  p4 <- ggarrange(predicted, actual, ncol = 2, 
                  labels = c(paste("Predicted", var), paste("Actual", var)), 
                  common.legend = TRUE, widths = c(1,1))
  
  ggsave(paste("figures/lmer_figs/", var, "_pred_actual.pdf", sep = ""), plot = p4)

  # Plot the estimates with confidence intervals
  fe <- fixef(model)
  ci <- confint(model)

  cife <- data.frame(ci[4:6,], fe, "disturbance" = c("historic", "hurricane", "disease"))
  colnames(cife) <- c("lower", "upper", "fixedeff", "disturbance")
  cife$disturbance <- factor(cife$disturbance, levels = c("historic", "hurricane", "disease"))

  cife_noIntercept <- cife[2:3,]
  
  # Plot the coefficients with the confidence intervals (95%). If they go through zero that indicates less confidence in the change
  p5 <- ggplot(cife_noIntercept, aes(x = disturbance, y = fixedeff, color = disturbance)) +
    geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
    geom_point(size = 5) +
    geom_errorbar(data = cife_noIntercept, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
    scale_color_manual(values = c("#D95F02", "#7570B3")) +
    labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic", title = paste(var))
  
  ggsave(paste("figures/lmer_figs/", var, "_estimate_CI.pdf", sep = ""), plot = p5, height = 3, width = 3)

  # Add results to a list
  results_list[[i]] <- list(
    variable = variables[i],
    model_summary = summary(model), 
    time_LRT_results = time_LRT, 
    site_LRT_results = site_LRT, 
    disturbance_LRT_results = disturbance_LRT, 
    CI_95 = ci
  )
  
  # Add confidence interval results to a list so I can easily make a lot of graphs after this
  CI_list[[i]] <- list(
    variable = variables[i],
    conf_int = cife_noIntercept
  )
}
```
# LMM assumption testing

Goal - I conducted all the Linear mixed effects models and produced the figures where I could assess the model assumptions, but I didn't adjust the data to fit the model assumptions. 
I need to go test by test and change the data (mostly removing outliers) and re-run the analysis to evaluate if the outliers or not meeting assumptions is impacting the results I am getting. 
I need to do this due diligence so that I can be confident in the statistical approaches I am choosing. 
```{r phosphate}
# analyze phosphate. In the first model, there were three clear outliers in the residuals that was leading to non-normal data and right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "po4_um")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "po4_um"
  
  # Open a PDF file for saving plots
 # pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Which samples are the high residuals so I can remove them?
high.residuals <- res > 0.05
table(high.residuals) # found the top 3, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < 0.04,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)

# results are overall the same as before removing outliers, so just use the original test. 
```

When comparing the results of the phosphate model before and after removing outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found no change in the overall trends of the results. As such, I will proceed reporting the results of the original model as it includes all the relevant data points. 

```{r silicate}
# analyze silicate. In the first model, there was a clear outlier in the residuals that was leading to non-normal data and right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "silicate_um")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "silicate_um"
  
  # Open a PDF file for saving plots
 # pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = 2
high.residuals <- res > cutoff
table(high.residuals) # found the top 3, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < cutoff,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)
  

# Results are no different than from before removing outliers, so just use the original results. 
```

When comparing the results of the silicate model before and after removing the outlier to satisfy the assumptions of normality and homogeneity of variance of residuals, I found no change in the overall trends of the results. As such, I will proceed reporting the results of the original model as it includes all the relevant data points. 

```{r prochlorococcus}
# analyze prochlorococcus. In the first model, there was a clear outlier in the residuals that was leading to non-normal data and right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "pro_per_ml")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "pro_per_ml"
  
  # Open a PDF file for saving plots
 # pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = -50000
high.residuals <- res < cutoff
table(high.residuals) # found the top 3, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res > cutoff,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)

# Results are no different than from before removing outliers, so just use the original results. 
```

When comparing the results of the prochlorococcus model before and after removing the outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found no change in the overall trends of the results. As such, I will proceed reporting the results of the original model as it includes all the relevant data points. 

```{r picoeukaryotes}
# analyze picoeukaryotes. In the first model, there were some clear outliers in the residuals that was leading to non-normal data and right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "peuk_per_ml")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "peuk_per_ml"
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
qqline(res)
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
# Close the PDF file
# dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = 1500
high.residuals <- res > cutoff
table(high.residuals) # found the top 3, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < cutoff,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
qqline(res.filt)
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
# run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)

# Results are different, so use the new set of data
# Plot the estimates with confidence intervals
  fe <- fixef(model.filt)
  ci <- confint(model.filt)

  cife <- data.frame(ci[4:6,], fe, "disturbance" = c("historic", "hurricane", "disease"))
  colnames(cife) <- c("lower", "upper", "fixedeff", "disturbance")
  cife$disturbance <- factor(cife$disturbance, levels = c("historic", "hurricane", "disease"))

  cife_noIntercept <- cife[2:3,]
  
  # Plot the coefficients with the confidence intervals (95%). If they go through zero that indicates less confidence in the change
p5 <- ggplot(cife_noIntercept, aes(x = disturbance, y = fixedeff, color = disturbance)) +
    geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
    geom_point(size = 5) +
    geom_errorbar(data = cife_noIntercept, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
    scale_color_manual(values = c("#D95F02", "#7570B3")) +
    labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic", title = paste(var))

p5

ggsave(paste("figures/lmer_figs/", var, "_no_outlier_estimate_CI.pdf", sep = ""), plot = p5, height = 3, width = 3)

# Save the picoeukaryote data 
cife_Peuk_per_ml <- tibble("variable" = c("peuk_per_ml", "peuk_per_ml"), cife_noIntercept)
```
When comparing the results of the picoeukaryote model before and after removing the outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found some change in the overall trends of the results. Specifically, site as a random effect significantly improved model fit in the new results, while before it didn't. As such, I will proceed reporting the results of the NEW model as it removed outliers that were leading to the failure of the model to meet assumptions. 

```{r Ramicrusta}
# analyze Ramicrusta.  In the first model, there were some outliers in the residuals that was leading to non-normal data and right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "Ramicrusta")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "Ramicrusta"
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
qqline(res)
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
# Close the PDF file
# dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = 0.1
high.residuals <- res > cutoff
table(high.residuals) # found the top 3, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < cutoff,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
qqline(res.filt)
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)

# Results are different, so use the new set of data
# Plot the estimates with confidence intervals
fe <- fixef(model.filt)
ci <- confint(model.filt)

cife <- data.frame(ci[4:6,], fe, "disturbance" = c("historic", "hurricane", "disease"))
colnames(cife) <- c("lower", "upper", "fixedeff", "disturbance")
cife$disturbance <- factor(cife$disturbance, levels = c("historic", "hurricane", "disease"))

cife_noIntercept <- cife[2:3,]
  
# Plot the coefficients with the confidence intervals (95%). If they go through zero that indicates less confidence in the change
p5 <- ggplot(cife_noIntercept, aes(x = disturbance, y = fixedeff, color = disturbance)) +
    geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
    geom_point(size = 5) +
    geom_errorbar(data = cife_noIntercept, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
    scale_color_manual(values = c("#D95F02", "#7570B3")) +
    labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic", title = paste(var))

p5

ggsave(paste("figures/lmer_figs/", var, "_no_outlier_estimate_CI.pdf", sep = ""), plot = p5, height = 3, width = 3)

cife_Ramicrusta <- tibble("variable" = c("Ramicrusta", "Ramicrusta"), cife_noIntercept)
```
When comparing the results of the Ramicrusta model before and after removing the outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found some change in the overall trends of the results. Specifically, disturbance was significant at p<0.05 at impacting Ramicrusta. But before outlier removal, the model assumptions were not as well met and the disturbance was significant at p<0.10. 

```{r Turf Alage}
# analyze Turf Algae.  In the first model, there were two outliers in the residuals that was leading to slightly non-normal data and sightly right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "TurfAlgae")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "TurfAlgae"
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
qqline(res)
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
# Close the PDF file
# dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = 0.2
high.residuals <- res > cutoff
table(high.residuals) # found the top 3, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < cutoff,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
qqline(res.filt)
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)

```
When comparing the results of the Turf Algae model before and after removing the outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found no change in the overall trends of the results. As such, I will proceed reporting the results of the original model as it includes all the relevant data points. 

```{r Biomass Ratio}
# analyze Biomass Ratio.  In the first model, there were two outliers in the residuals that was leading to slightly non-normal data and sightly right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "biomassRatio")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "biomassRatio"
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
qqline(res)
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
# Close the PDF file
# dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = 1
high.residuals <- res > cutoff
table(high.residuals) # found the top 3, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < cutoff,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
qqline(res.filt)
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)
```
When comparing the results of the Biomass ratio model before and after removing the outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found no change in the overall trends of the results. As such, I will proceed reporting the results of the original model as it includes all the relevant data points. 

```{r Algae to Coral Ratio}
# analyze Biomass Ratio.  In the first model, there were two outliers in the residuals that was leading to slightly non-normal data and sightly right-skewed data. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "AlgaeToCoral")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "AlgaeToCoral"
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
qqline(res)
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
# Close the PDF file
# dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = 3.5
high.residuals <- res > cutoff
table(high.residuals) # found the top 2, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < cutoff,]
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
qqline(res.filt)
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)

```

When comparing the results of the Algae to coral ratio model before and after removing the outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found no change in the overall trends of the results. As such, I will proceed reporting the results of the original model as it includes all the relevant data points. One small change was the p-values of the individual tests. While disturbance overall wasn't significant, disease was significant at p<0.1 in first test, but isn't in the second test. These results likely arent important to highlight though since disturbance overal wasnt significant. 

```{r TOC}
# analyze TOC.  In the first model, there were outliers in the residuals that was leading to slightly non-normal data and sightly right-skewed data. Additionally, there was one timepoint, 2016-10 that had abnormally high total organic carbon values and it is unclear why. I am tempted to remove them and re-try the analysis. 
# Re-run and check the outliers and results after removing the outliers. 
env.data.foranalysis

envdata <- filter(env.data.foranalysis, datatype == "npoc_um")
  
model <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata)

summary(model)
  
# save the predicted and raw values
pred <- predict(model)
res <- residuals(model)
res.pred.data <- data.frame(pred, res, envdata)
  
var <- "npoc_um"
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred, y = res)
abline(h = 0)
qqnorm(res) 
qqline(res)
hist(res)
plot.new()
text(0.5,0.5, paste(var), cex=2)
# Close the PDF file
# dev.off()

# Which samples are the high residuals so I can remove them?
# set the residual number to remove
cutoff = 20
high.residuals <- res > cutoff
table(high.residuals) # found the top 2, need to remove

dim(res.pred.data)
envdata.filt <- res.pred.data[res.pred.data$res < cutoff,]
# envdata.filt <- envdata.filt[envdata.filt$yearmonth != "2016-10",] # doesnt impact overall results so don't do this. 
dim(envdata.filt)

# Try running the data again with the filtered data and see if it impacts the broad findings:
model.filt <- lmerTest::lmer(value ~ disturbance + (1|site) + (1|yearmonth), data = envdata.filt)
summary(model.filt)
  
# save the predicted and raw values
pred.filt <- predict(model.filt)
res.filt <- residuals(model.filt)
res.pred.data <- data.frame(pred.filt, res.filt, envdata.filt)
  
# Open a PDF file for saving plots
# pdf(paste("figures/lmer_figs/", var, "_assumptions.pdf", sep = ""))
  
par(mfrow=c(2,2))
plot(x = pred.filt, y = res.filt)
abline(h = 0)
qqnorm(res.filt) 
qqline(res.filt)
hist(res.filt)
plot.new()
text(0.5,0.5, paste(var), cex=2)
  # Close the PDF file
#dev.off()

# Happy with new assumptions, now run the rest of it to find out answers. 

# Make models with and without the random effects and a null model without disturbance as fixed effect
notime_model <- lmerTest::lmer(value ~ disturbance + (1|site), data = envdata.filt)
nosite_model <- lmerTest::lmer(value ~ disturbance + (1|yearmonth), data = envdata.filt)
null_model <- lmerTest::lmer(value ~ 1 + (1|site) + (1|yearmonth), data = envdata.filt)
  
  # run a likelihood ratio test to evaluate if additional random/fixed effects leads to a better fit of the model
time_LRT <- anova(model.filt, notime_model)
site_LRT <- anova(model.filt, nosite_model)
disturbance_LRT <- anova(model.filt, null_model)

```

When comparing the results of the Biomass ratio model before and after removing the outliers to satisfy the assumptions of normality and homogeneity of variance of residuals, I found no change in the overall trends of the results. As such, I will proceed reporting the results of the original model as it includes all the relevant data points. 

# REVISION FIG 2 and SUPP FIGS
```{r}
# need confidence interval data from LMM for loop
CI_list %>% str
CI_df <- ldply(CI_list, data.frame)

# remove the ramicrusta and picoeukaryote data from this since you had to adjust those models to fit the assumptionsof a linear mixed effects model
# Then add the ramicrusta and picoeukaryote data back in fromm the updated model
CI_df_all <- CI_df %>%
  filter(variable != "Ramicrusta") %>%
  filter(variable != "peuk_per_ml") %>% # remove the old ramicrusta and picoeukaryote data
  rename(lower = conf_int.lower, 
         upper = conf_int.upper, 
         fixedeff = conf_int.fixedeff, 
         disturbance = conf_int.disturbance) %>% # rename columns so you can bind rows
  bind_rows(cife_Peuk_per_ml) %>%
  bind_rows(cife_Ramicrusta) # add new data

# Figure combos to create
# 1. Ramicrusta, Turf algae, and macroalgae for Figure 2
CI_df_fig2 <- CI_df_all %>%
  filter(variable %in% c("Ramicrusta", "TurfAlgae", "Macroalgae")) %>%
  mutate(variable = factor(variable, levels = c("Ramicrusta", "TurfAlgae", "Macroalgae")))

a <- ggplot(CI_df_fig2, aes(x = disturbance, y = fixedeff, color = disturbance)) +
    geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
    geom_point(size = 5) +
    geom_errorbar(data = CI_df_fig2, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
    scale_color_manual(values = c("#D95F02", "#7570B3")) +
    facet_wrap(. ~ variable, scales = "free", ncol = 2) +
    labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic")

# 2. Supplementary figure of all the benthic components that werent significantly distinct
CI_df_suppfig1 <- CI_df_all %>%
  filter(variable %in% c("HardCoral", "SoftCoral", "AlgaeToCoral")) %>%
  mutate(variable = factor(variable, levels = c("HardCoral", "SoftCoral", "AlgaeToCoral")))

b <- ggplot(CI_df_suppfig1, aes(x = disturbance, y = fixedeff, color = disturbance)) +
    geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
    geom_point(size = 5) +
    geom_errorbar(data = CI_df_suppfig1, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
    scale_color_manual(values = c("#D95F02", "#7570B3")) +
    facet_wrap(. ~ variable, scales = "free", ncol = 3) +
    labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic", title = "Supp Fig. Benthic components not significantly different with disturbance")

# 3. Supplementary figure of all the nutrients and cell abundances that weren't significantly different (all but ammonium)
CI_df_suppfig2 <- CI_df_all %>%
  filter(variable %in% c("po4_um", "silicate_um", "no2_um", "pro_per_ml", "syn_per_ml", "hbact_per_ml", "TON", "npoc_um", "Chl_ug_per_l", "no3_um", "peuk_per_ml")) %>%
  mutate(variable = factor(variable, levels = c("pro_per_ml", "syn_per_ml", "peuk_per_ml", "hbact_per_ml", "silicate_um", "npoc_um", "TON",  "Chl_ug_per_l", "no2_um", "no3_um", "po4_um")))

c <- ggplot(CI_df_suppfig2, aes(x = disturbance, y = fixedeff, color = disturbance)) +
    geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
    geom_point(size = 5) +
    geom_errorbar(data = CI_df_suppfig2, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
    scale_color_manual(values = c("#D95F02", "#7570B3")) +
    facet_wrap(. ~ variable, scales = "free", ncol = 4) +
    labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic", title = "Supp Fig. Nutrients and microbes not significantly different with disturbance")

## Conduct a PCA
benthic <- envdata %>%
  filter(site != "USVI Blue Water") %>%
  dplyr::select(Date, site, siteacronym, depthtype, yearmonth, disturbance, BleachCoral, CCA, CYAN, DiseasedCoral, HardCoral, Macroalgae, Other, Ramicrusta, SoftCoral, Sponge, Substrate, TurfAlgae) %>%
  mutate(site = factor(site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))) %>%
  drop_na(HardCoral) %>%
  filter(site != "Sand patch") %>% #no need to calculate sand patch stuff
  mutate(Other = Other + BleachCoral) %>%
  dplyr::select(-BleachCoral) %>% #no need for this section
  mutate(disturbance = factor(disturbance, levels = c("historic", "hurricane", "disease")))

# Prep the benthic data 
pca_data_short_final <- as.matrix(benthic) #change from tibble to matrix
rownames(pca_data_short_final) <- pca_data_short_final[,3] #make rownames the unique sites
pca_data_short_final <- pca_data_short_final[,7:17] #select numeric variables
class(pca_data_short_final) <- "numeric" #change from character to numeric values for pca

#Do the PCA
pca <- PCA(pca_data_short_final, scale.unit=TRUE, graph = FALSE) #performs the Principal component analysis #scale.unit=TRUE then data are scaled to unit variance

#All pca values for density plots to acompany the ggplot summary figure
pcaAll <- cbind(benthic, pca$ind$coord[,1:2]) %>%
  mutate(disturbance = factor(disturbance, levels = c("historic", "hurricane", "disease")))

pcaVars <- data.frame(pca$var$coord[,1:2], "variable" = rownames(pca$var$coord))

pcagraph <- ggscatter(pcaAll, x = "Dim.1", y = "Dim.2", color = "disturbance", size = 4, alpha = 0.7, palette = "Dark2") +
  labs(x = "PC1 (27.2%)", y = "PC2 (15.2%)") +
  border()+
  theme(legend.position = "none") +
  geom_segment(data = pcaVars, aes(x = 0, xend = Dim.1*4, y = 0, yend = Dim.2*4), arrow = arrow(length = unit(0.25, "cm"))) +
  geom_text(data = pcaVars, aes(x = Dim.1*4, y = Dim.2*4, label = variable)) +
  coord_fixed()

#Use vegan for the benthic pca stuff - PCAs are made with euclidian distance so use adonis function but make sure method = "eu"
# Interested in how environmental variables influence benthic composition
site <- adonis2(pca_data_short_final ~ site, data = benthic, method = "eu")
site

dist <- adonis2(pca_data_short_final ~ disturbance, data = benthic, method = "eu")
dist

date <- adonis2(pca_data_short_final ~ Date, data = benthic, method = "eu")
date

timepoint <- adonis2(pca_data_short_final ~ yearmonth, data = benthic, method = "eu")
timepoint

cx <- ggplot(pcaAll, aes(x = disturbance, y = Dim.1, fill = disturbance)) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Dark2") +
  rotate() +
  clean_theme()+
  theme(legend.position = "none")

dy <- ggplot(pcaAll, aes(x = disturbance, y = Dim.2, fill = disturbance)) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Dark2") +
  clean_theme() +
  theme(legend.position = "none")

# FIGURE 2
# Arranging the plot
fig2 <- ggarrange(ggarrange(cx, NULL, pcagraph, dy, 
          ncol = 2, nrow = 2,  align = "hv", 
          widths = c(4,1), heights = c(1, 4)), 
          a, labels = c("a.", "b."))
ggsave("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/Publication_Figures/EMI_Revision_Figures/Fig2_benthic_changes.pdf", width = 10, height = 5)
annotate_figure(fig2, top = "Figure 2. Benthic composition at eight reefs significantly changed with disturbances")

# SUPPLEMENTARY FIGURE
b
ggsave("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/Publication_Figures/EMI_Revision_Figures/SuppFig_benthic_changes_notsig.pdf")
# SUPPLEMENTARY FIGURE
c
ggsave("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/Publication_Figures/EMI_Revision_Figures/SuppFig_nut_microbe_changes_notsig.pdf", width = 8, height = 7)
```

# REVISION FIG 3 Code

The idea with Figure 3 is that I will now create a PCA of the environmental variables that I can reference. The idea is that this shows how mych the time of year and sampling time point influences the nutrient and cell abundances. Then I will also say, despite this, ammonium was the only nutrient that did chage as a result of the disturbances
```{r}
## Look at pairwise correlation between the variables in all the environmental data
data_cor_all <- envdata %>%                        
  dplyr::select(Date, site, siteacronym, depthtype, yearmonth, disturbance, month, temp_c:hbact_per_ml) %>% 
  mutate(TON = tn_um - (no2no3_um + nh4_um)) %>%
  mutate(no3 = no2no3_um - no2_um) %>%
  mutate(site = factor(site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))) %>%
  dplyr::select(-Phaeo_ug_per_l, -no2no3_um, -tn_um) %>%
  filter(site != "Sand patch") %>%
  mutate(disturbance = factor(disturbance, levels = c("historic", "hurricane", "disease")))

data_cor_all2 <- data_cor_all[,8:21]                                # select indep. variables
var <- cor(data_cor_all2, use = "complete.obs", method = "pearson")  # correlation matrix  with casewise deletion of missing values

colnames(var) <- colnames(data_cor_all2)                    # rename the row names and column names
rownames(var) <- colnames(data_cor_all2)
corrplot(var, method='number')                              # visualize any multicollinearity

# Remove collinear variables with correlation greater than abs(0.7)
toremove <- var < (-0.7)

# Variables with TRUE are Salinity, silicate, and nitrate

## Based on this, I will remove: Silicate, Salinity, and Nitrate from this analysis (anything with correlation greater than 0.7)

# Also keep all data for analysis
collinear_remove <- data_cor_all %>%
  filter(yearmonth != "2022-06") %>% # remove june 2022 since no cell count data
  dplyr::select(!c(silicate_um, salinity, no3))

## BENTHIC and SURFACE TOGETHER ANALYSIS ##

# I did a test comparing depth of all variables and most were not significantly different in value between the surface and benthic values, so I am going to combine both for an analysis

allmatrix <- as.matrix(collinear_remove) #change from tibble to matrix
rownames(allmatrix) <- allmatrix[,3] #make rownames the unique sites
allmatrix_vars <- allmatrix[,8:18] #select numeric variables
class(allmatrix_vars) <- "numeric" #change from character to numeric values for pca

## impute missing values
replaceMissing_all <- imputePCA(allmatrix_vars)
allmatrix_vars_noNA <- replaceMissing_all$completeObs

#Do the PCA
pca_all<- PCA(allmatrix_vars_noNA, scale.unit=TRUE) #performs the Principal component analysis, and replaces missing values. #scale.unit=TRUE then data are scaled to unit variance
print(pca_all)

get_eigenvalue(pca_all)
fviz_eig(pca_all) #1st dimension is most. First 2 should be sufficient

all_pca_viz <- fviz_pca(pca_all,
         geom=c("point"),
         pointshape=21,
         pointsize=3,
         fill.ind=collinear_remove$yearmonth,
         invisible="quali", # gets rid of the unequally sized dots, so all of them are equal in size
         geom.var =c("arrow", "text"),
         col.var = "black",
         repel=TRUE,
         title="PCA of environmental variables",
         legend.title=list(fill="Time")) +
  scale_fill_viridis(discrete = TRUE) +
  coord_fixed() +
  theme_bw()

all_pca_viz

#Use vegan for the PERMANOVA tests on benthic pca stuff - PCAs are made with euclidian distance so use adonis function but make sure method = "eu
site <- adonis2(allmatrix_vars_noNA ~ site, data = collinear_remove, method = "eu")
site
yearmonth <- adonis2(allmatrix_vars_noNA ~ yearmonth, data = collinear_remove, method = "eu")
yearmonth
dist <- adonis2(allmatrix_vars_noNA ~ disturbance, data = collinear_remove, method = "eu")
dist

# Save the graph of only ammonium from the LMM analysis
# Need the CI_df_all data frame
nh4_ci <- CI_df_all %>%
  filter(variable == "nh4_um")

nh4 <- ggplot(nh4_ci, aes(x = disturbance, y = fixedeff, color = disturbance)) +
    geom_hline(yintercept = 0, color = "#1B9E77", size = 1) +
    geom_point(size = 5) +
    geom_errorbar(data = nh4_ci, aes(ymin = lower, ymax = upper), width = 0.2, size = 1.5) +
    scale_color_manual(values = c("#D95F02", "#7570B3")) +
    labs(x = "Disturbance", y = "Estimate with 95% CI relative to Historic", title = "b. Ammonium")

# Put the 2 graphs together using ggpubr
ggarrange(all_pca_viz, ggarrange(nh4, NULL, ncol = 1), 
                    labels = c("a.", "b."), 
          widths = c(2,1)) 
#ggsave("/Users/cynthiabecker/Documents/Apprill_lab/USVI_Projects/Publication_Figures/EMI_Revision_Figures/Fig3_envdata_changes.pdf", width = 10, height = 5)
```


# REVISION FIGs Differential Abundance 

One reviewer found the grouping into different disturbances to be an oversimplification of the data. Using a regression based approach would be much better according to this reviewer. I would like to try the regression approach. 
One key finding of the environmental data was the significant increase in ammonium on St. John reefs over time and coincident with disturbances. Ammonium directly impacts microbial communities as multiple heterotrophic and autotrophic microorganisms can assimilate ammonium or produce ammonium. 
I am interested in understanding which microorganisms increase or decreased within the water column of st. john reefs in response to ammonium enrichment. 
Ideally, the results will tie back to then microorganisms that increased or decreased with disturbances on reefs. With differential abundance tests I will evaluate disturbance --> nutrient enrichment --> microbial changes. And with random forests we will see which microbial changes --> nutrient enrichment --> disturbances

### Load data
```{r}
# Prep the phyloseq object - represents low-abundance filtered data
sample_data(ps)$site <- factor(sample_data(ps)$site, levels = c("Dittlif", "Cocoloba", "Joels Shoal", "Europa", "Yawzi", "Tektite", "Booby Rock", "Ram Head", "Sand patch"))
sample_data(ps)$disturbance <- factor(sample_data(ps)$disturbance, levels = c("historic", "hurricane", "disease"))
sample_data(ps)$yearmonth <- factor(sample_data(ps)$yearmonth, levels = c("2016-06", "2016-10", "2017-03", "2017-07", "2017-11", "2018-04", "2018-11", "2020-08", "2021-01", "2021-10", "2022-06"))

# Remove Ammonium values that were outliers and weren't in the environmental analysis. Also remove NAs
sample_data(ps)$missingnh4 <- is.na(sample_data(ps)$nh4)
sample_data(ps)$outliernh4 <- sample_data(ps)$nh4 > 0.8
ps.nh4.narm <- ps %>%
  subset_samples(missingnh4 == "FALSE") %>%
  subset_samples(outliernh4 == "FALSE")

# BENTHIC DATA - You are only analyzing the benthic data for the differential abundance and random forest stuff. It was not significantly different from the surface, and I would like to use the surface waters to test the RF model. 
ps.benthic.nh4.narm <- ps.nh4.narm %>%  # name with nh4 so you know it is for the ammonium test
  subset_samples(site != "Sand patch") %>%
  subset_samples(depth == "Benthic")

# Try renaming all the NA taxa using the fantaxtic package Natasha sent me
ps.benthic.nh4.narm <- name_na_taxa(ps.benthic.nh4.narm, 
                                        na_label = "Unclassified <tax> (<rank>)")
```


### Benthic community

```{r disturbance benthic, message=FALSE}
# What microorganisms are significantly changing with changes in ammonium? 

set.seed(1)
nh4_narm.da <- differentialTest(formula = ~ nh4, 
                             phi.formula = ~ nh4,
                             formula_null = ~ 1,
                             phi.formula_null = ~ nh4,
                             test = "LRT", boot = FALSE,
                             data = ps.benthic.nh4.narm,
                             fdr_cutoff = 0.05)

nh4_narm.da_fdr0.1 <- differentialTest(formula = ~ nh4, 
                             phi.formula = ~ nh4,
                             formula_null = ~ 1,
                             phi.formula_null = ~ nh4,
                             test = "LRT", boot = FALSE,
                             data = ps.benthic.nh4.narm,
                             fdr_cutoff = 0.10)

# This didn't make much of a difference

# save the nh4_narm.da output and add asv, p.adj values to it, and ultimately taxonomny info
nh4.da.models <- lapply(nh4_narm.da$significant_models, extractmods2)
names(nh4.da.models) <- nh4_narm.da$significant_taxa

# Add ASVs to the taxonomy table and save the significant asvs
tax_table(ps.benthic.nh4.narm)[,7] <- rownames(tax_table(ps.benthic.nh4.narm))
sig.taxonomy.nh4 <- as.data.frame(tax_table(ps.benthic.nh4.narm)[nh4_narm.da$significant_taxa,]) 

# Move the data from a list to a dataframe and add taxonomy info
nh4.da.models.df <- ldply(nh4.da.models, data.frame) %>% 
  left_join(sig.taxonomy.nh4, by = c(".id" = "Species")) %>%
  mutate(genusasv = paste0(Genus, "_(", .id,")"))

### Save these data so you don't have to re-run the model ###
#write.table(nh4.da.models.df, "data/Sig_ASVs_NH4_Oct23.txt", sep="\t",row.names = FALSE)
```
So I saved the output of all the ASVs that were differentially enriched or depleted with ammonium. 

### What are the taxonomic assignments of differentially abundant taxa? Look and plot them

```{r Corncob_results, message=FALSE, warning=FALSE}
DAnh4 <- read_delim("data/Sig_ASVs_NH4_Oct23.txt", delim = "\t", col_names = TRUE)

DAnh4_desc <- DAnh4 %>% 
  arrange(desc(Class), Estimate)

kable(DAnh4_desc)

# plot the differential abundance results

genusASVorder <- DAnh4_desc %>%
  arrange(desc(Class), Estimate) %>%
  dplyr::select(genusasv) %>%
  unique() 

DAnh4_desc$genusasv <- factor(DAnh4_desc$genusasv, levels = as.vector(genusASVorder$genusasv))
DAnh4_desc$Class <- factor(DAnh4_desc$Class, levels = c("Acidimicrobiia", 
                                                        "Alphaproteobacteria", 
                                                "Bacteroidia",
                                                "Cyanobacteriia",
                                                "Gammaproteobacteria", 
                                                "Unclassified SAR324 clade(Marine group B) (Phylum)", 
                                                "Verrucomicrobiae"))

palcolors <- c("#CC7A88", "#99600F", "#CCAA7A", "#54990F", "#3D0F99", "#967ACC","#0F8299",  "#7ABECC", "#333333", "#999999")

ggplot(DAnh4_desc, aes(x = genusasv, y = Estimate, color = Class)) +
  geom_errorbar(aes(ymin = Estimate-Std.Error, ymax = Estimate+Std.Error), color = "black", width = .3, position=position_dodge(.9)) +
  geom_point(size = 4) +
  coord_flip() +
  theme_bw() +
  labs(x = "Taxa", y = "Differential Abundance") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "darkgray") +
  theme(plot.background = element_blank(), 
        legend.position = "bottom") +
  scale_color_manual(values = palcolors)
```

# Random Forest Analysis
```{r}
# Use the same phyloseq object where I removed the samples with NAs for the ammonium values

# BENTHIC FILTERED data (~1000 taxa)
ps.benthic.nh4.narm.filt <- ps.benthic.nh4.narm %>% 
  filter_taxa(function(x) mean(x) > 0.5, TRUE) # keep if avg abundance 0.5 counts

taxa <- ps.benthic.nh4.narm.filt %>% tax_table() %>% rownames

# Get surface taxa based on the asvs in the benthic seawater - This will be for validation of the random forest model

ps.surface.nh4.narm.filt <- ps.nh4.narm %>% 
  subset_samples(site != "Sand patch") %>%
  subset_samples(depth == "Surface") %>%
  mutate_tax_table(ASV = .otu) %>% 
  subset_taxa(ASV %in% taxa)
```

## Generate and test random forest model
```{r RF model}
## RANDOM FOREST ANALYSIS ##
# get the ASVs as columns and samples as rows, which are the predictors
predictors <- t(otu_table(ps.benthic.nh4.narm.filt))

# response variable is ammonium
response <- sample_data(ps.benthic.nh4.narm.filt)$nh4

# combine with the ASV table
resp.pred <- data.frame(response, predictors)

# set seed for reproducibility and this is the main random forest model
set.seed(10)
nh4.RF <- randomForest(response ~ ., data = resp.pred, ntree = 1000, importance = TRUE)

print(nh4.RF)

# Explains 66% of variance?!?!?!?!?!? That is way higher than anything I tried before


# Look at the predicted ammonium compared to actual ammonium in BENTHIC data
predicted.actual.benthic <- data.frame("predicted" = nh4.RF$predicted, "actual" = resp.pred$response)

ggplot(predicted.actual.benthic, aes(x = actual, y = predicted)) +
  geom_point() +
  geom_smooth(method = 'lm', se = FALSE) +
  labs(x = "Actual ammonium", y = "Predicted ammonium", 
       title = "Prediction of ammonium from Random Forest model on benthic data")

# Validate the model on surface data
validation.pred <- t(otu_table(ps.surface.nh4.narm.filt))

validation.resp <- sample_data(ps.surface.nh4.narm.filt)$nh4

valid.pred.resp <- data.frame(validation.resp, validation.pred)

prediction_surface <- predict(nh4.RF, valid.pred.resp[,-1])

predicted.actual.surface <- data.frame("predicted" = prediction_surface, 
                                       "actual" = sample_data(ps.surface.nh4.narm.filt)$nh4)

ggplot(predicted.actual.surface, aes(x = actual, y = predicted)) +
  geom_point() +
  geom_smooth(method = 'lm', se = FALSE) +
  labs(x = "Actual ammonium", y = "Predicted ammonium", 
       title = "Prediction of ammonium in surface water", 
       subtitle = "Prediction using Random Forest model trained on benthic ammonium data")

# I need to calculate the mean squared error between the actual and predicted values using the model on the test set (surface seawater data)
mse_predict <- mean((prediction_surface-validation.resp)^2) #on the trained surface data
mse_predict

mse_model <- mean((nh4.RF$predicted-resp.pred$response)^2) #on the benthic data - direct from the model
mse_model
# THIS IS PRETTY LOW COMPARED TO THE ONLINE TUTORIALS I AM FINDING
```

## Save Random Forest data output
```{r}
# make a data frame with predictor names and the importance value
imp <- importance(nh4.RF)
imp <- data.frame(predictors = rownames(imp), imp)

# order the predictor levels by importance (higher number is more important)
imp.sort.Accuracy <- arrange(imp, desc(X.IncMSE))

# Select the top 50 important taxa based on the Mean Decrease Accurracy metric
imp.50.acc <- imp.sort.Accuracy[1:50,]

# Save a table of the top 50 ASVs
ASV.50.acc <- imp.50.acc$predictors
r <- rownames(tax_table(ps.benthic.nh4.narm.filt)) %in% ASV.50.acc
table <- tax_table(ps.benthic.nh4.narm.filt)[r,]

table <- as.data.frame(table)
table$ASV <- rownames(table)

tableAccuracy <- left_join(table, imp.50.acc, by = c("ASV" = "predictors"))

#write.table(tableAccuracy, "data/RandomForest_NH4_top50_accuracy_benthic.txt", sep = "\t", row.names = FALSE)

kable(table)

# Graph the top 50 taxa
tableAccuracy.genusasv <- tableAccuracy %>%
  mutate(genusasv = paste0(Genus, "_(", ASV,")"))

genusASVorder <- tableAccuracy.genusasv %>%
  arrange(desc(Class), X.IncMSE) %>%
  dplyr::select(genusasv) %>%
  unique() 

tableAccuracy.genusasv$genusasv <- factor(tableAccuracy.genusasv$genusasv, levels = as.vector(genusASVorder$genusasv))
tableAccuracy.genusasv$Class <- factor(tableAccuracy.genusasv$Class, levels = c("Alphaproteobacteria",
                                                                                "Bacteroidia",
                                                                                "Bdellovibrionia",
                                                                                "Cyanobacteriia",
                                                                                "Dadabacteriia",
                                                                                "Gammaproteobacteria",
                                                                                "Unclassified Marinimicrobia (SAR406 clade) (Phylum)",
                                                                                "Unclassified SAR324 clade(Marine group B) (Phylum)",
                                                                                "Thermoplasmata",
                                                                                "Verrucomicrobiae"))


# Graph all 50 taxa and their percent increase in MSE
ggplot(tableAccuracy.genusasv, aes(x = genusasv, y = X.IncMSE, fill = Class)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_manual(values = palcolors) +
  theme(plot.background = element_blank()) +
  labs(x = "Taxa", y = "% Increase MSE") +
  theme(legend.position = "bottom")

ggsave("figures/RF_Important_ASVs_NH4.pdf", height = 9)
```

Ultimately we want to have as small a mean squared error as possible in the model. The most important ASVs are those that reduce the variance in the model. In other words, when the ASV is removed, it leads to the highest INCREASE in MSE (mean square error) in the regression-based model. More error is generally bad. This is the metric that the random forest algorithm uses to identify an "IMPORTANT" ASV. I just chose arbitrarily to select the top 50 ASVs that are important based on their % increase in mean square error of the model when they are removed. 

# REVISED DA and RF figure
```{r message=FALSE}
DAtaxa <- read_delim("data/Sig_ASVs_NH4_Oct23.txt", delim = "\t", col_names = TRUE)

RFtaxa <- read_delim("data/RandomForest_NH4_top50_accuracy_benthic.txt", delim = "\t", col_names = TRUE)

RFasvs <- RFtaxa %>% 
  dplyr::select(ASV, X.IncMSE)

shared <- DAtaxa %>%
  left_join(RFasvs, by = c(".id" = "ASV")) %>%
  drop_na(X.IncMSE) # remove NAs, which indicates the microbe was NOT a predictor in the random forest analysis

# how many ASVs?
shared$.id %>% unique %>% length
```

Make a table of shared taxa
```{r}
importantASVs <- shared$.id %>% unique

r <- rownames(tax_table(ps.benthic.nh4.narm.filt)) %in% importantASVs

sharedtaxa <- as.data.frame(tax_table(ps.benthic.nh4.narm.filt)[r,])
```

Make the shared graph
```{r}
# corncob results
# order the taxa how i want them in the plot, with the archaea at the bottom
genusASVorder <- shared %>%
  arrange(desc(Class), Estimate) %>%
  dplyr::select(genusasv) %>%
  unique() 

shared$genusasv <- factor(shared$genusasv, levels = as.vector(genusASVorder$genusasv))
shared$Class <- factor(shared$Class, levels = c("Alphaproteobacteria", 
                                                "Bacteroidia",
                                                "Cyanobacteriia",
                                                "Gammaproteobacteria", 
                                                "Unclassified SAR324 clade(Marine group B) (Phylum)"))


palcolors <- c("#CC7A88", "#99600F", "#CCAA7A", "#54990F", "#3D0F99", "#967ACC","#0F8299",  "#7ABECC", "#333333", "#999999")

a <- ggplot(shared, aes(x = genusasv, y = Estimate, color = Class)) +
  geom_errorbar(aes(ymin = Estimate-Std.Error, ymax = Estimate+Std.Error), color = "black", width = .3, position=position_dodge(.9)) +
  geom_point(size = 4) +
  coord_flip() +
  theme_bw() +
  labs(x = "Taxa", y = "Differential Abundance") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "darkgray") +
  theme(plot.background = element_blank(), 
        legend.position = "bottom") +
  scale_color_manual(values = palcolors)

b <- ggplot(shared, aes(x = genusasv, y = X.IncMSE, fill = Class)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  scale_fill_manual(values = palcolors) +
  theme(plot.background = element_blank()) +
  labs(x = "Taxa", y = "% Increase MSE") +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")

a
b

wrap_plots(a, b, widths = c(1,1))

#ggsave("figures/DA_RF_shared_NH4_10.26.23.pdf", width = 9, height = 4.5)
```

Relative abundance of shared sensitive (differentially abundant) and predictive (random forests) taxa in relation to ammonium
```{r}
# Shared is from the section on "How many ASVs were shared?"
# prep the data
ASVshared <- shared %>%
  dplyr::select(.id) %>%
  unique()

ASVshared <- ASVshared$.id # must be a vector

# Take data from only benthic samples, since the main models were tested on benthic data. Could also show benthic AND surface if you want.
ps.shared.ra <- ps.benthic.nh4.narm %>%
  transform_sample_counts(function(x) x / sum(x)) %>%
  mutate_tax_table(ASV = .otu) %>%
  subset_taxa(ASV %in% ASVshared) 

ASVorder <- shared %>%
  arrange(Kingdom, desc(Class), Estimate) %>%
  dplyr::select(.id) %>%
  unique()

# plot relative abundance data
shared.ra.long <- ps.shared.ra %>%
  otu_table() %>%
  as_tibble() %>%
  left_join(as_tibble(tax_table(ps.shared.ra)), by = ".otu") %>%
  left_join(as_tibble(sample_data(ps.shared.ra)), by = ".sample") %>%
  mutate(genusasv = paste0(Genus, "_(", .otu, ")")) %>%
  mutate(.otu = factor(.otu, levels = as.vector(ASVorder$.id))) %>%
  mutate(genusasv = factor(genusasv, levels = as.vector(genusASVorder$genusasv))) %>% 
  mutate(Class = factor(Class, levels = c("Alphaproteobacteria", 
                                                "Bacteroidia",
                                                "Cyanobacteriia",
                                                "Gammaproteobacteria", 
                                                "Unclassified SAR324 clade(Marine group B) (Phylum)")))

ggplot(shared.ra.long, aes(x = nh4, y = .abundance)) +
  geom_point(aes(color = disturbance), size = 2, alpha = 0.7) +
  geom_smooth(method = 'lm', se = FALSE, color = "black") +
  facet_wrap(~ Class + genusasv, ncol = 5, scales = "free_y") +
  labs(y = "Relative abundance", x = "Ammonium (uM)", color = "Disturbance") +
  scale_color_brewer(palette = "Dark2") +
  theme(panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        legend.position = "bottom")

#ggsave("figures/DA_RF_shared_NH4_regression.pdf", width = 12, height = 6)
```